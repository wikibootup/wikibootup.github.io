<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      성찰11: 2020 업무 &middot; wikibootup
    
  </title>

  <script src="https://wikibootup.github.io/js/typed.min.js" type="text/javascript"></script>

  
  <link rel="stylesheet" href="https://wikibootup.github.io/css/app.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://wikibootup.github.io/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://wikibootup.github.io/assets/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://wikibootup.github.io/atom.xml">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-93792142-1', 'auto');
  ga('send', 'pageview');

</script>


</head>


  <body>

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
  </div>
  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="https://wikibootup.github.io/post">Posts</a>

    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </nav>

  <div class="sidebar-item">
    <p>Made by 
      <a href="https://twitter.com/mdo" target="_blank">@mdo</a>.
    </p>
    <p>&copy; 1. All rights reserved.</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://wikibootup.github.io/" title="Home">wikibootup</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">


<div class="post">
  <span class="post-date">Dec 15, 2020</span>
  <h1 class="post-title">성찰11: 2020 업무</h1>
  <div class="font-normal">
    <hr>
<p>이 글은 2020년 한 해 동안 개인적으로 업무 가운데 기술과 기획 부분에서 인상 깊었던 부분과 협업을 위한 문서들을 정리해보는 글이다.</p>
<hr>
<h3 id="1-프로덕트-매니징">1. 프로덕트 매니징</h3>
<p>작년까지 나는 제품 기획에 대해서 아는 것이 거의 없었다. 그런데 올해 운 좋게 좋은 기획을 경험하면서 여러 가지 발전적인 부분을 배울 수 있었다.</p>
<p>기획적 관점이 프로덕트에 자리 잡기 전까지 여러 가지 개선할 점들이 있었지만 그중에 네 가지만 추려 보았다.</p>
<h4 id="1-a-서비스-관점에서-프로덕트-전체-스펙에-대한-이해도">1-a. 서비스 관점에서 프로덕트 전체 스펙에 대한 이해도</h4>
<p>현재 서비스의 명세들을 제대로 이해하고 있지 못하다 보니 무언가 새로 만드려고 할 때에도, 개선하려고 할 때에도, 고객에게 설명을 하려고 할 때에도 어려움이 있었다. 당시에는 서비스 파악 수준이 부족했다. 그것이 서비스를 기획하는 데에 병목이 됐다.</p>
<p>왜 이런 문제가 생긴 것일까? 여러 해석이 가능하겠지만 개인적으로는 그 근본적인 원인이 서비스 관점에서 프로덕트를 바라보는 노력이 부족했기 때문이라는 생각을 한다. 기술적 관점에 치우쳐 있었기 때문에 누가 물어볼 때 어떤 기술적 방법이 들어갔고, 어떤 예외 처리가 적용되어 있는지는 답변해줄 수 있어도 ‘고객이 저 기능을 이런 용도로 이용할 수 있어요?’라는 질문에는 쉽게 답을 할 수가 없었다.</p>
<h4 id="1-b-문서화">1-b. 문서화</h4>
<p>기획/서비스 관점에서 참고할만한 문서가 별로 없었다. 문서로 명세를 파악할 수 없으니 동료는 기술자에게 직접 물어봐야만 알 수 있었고, 사실 물어봐도 서비스 관점에서 필요한 수준으로 답을 잘해주지 못했다.</p>
<p>물론, 문서가 별로 없었던 것에 이유가 없었던 것은 아니다. 그렇지만 기획 시스템이 도입될 시기에는 이것이 부채가 되어 돌아왔다.</p>
<p>배경은 이렇다. 보통 업무 문서를 작성하는 이유는 공유하거나 다시 보기 위해서 작성하는 데에 있을 것이다. 그런데 문서는 작성하는 데에 꽤 시간이 걸리고, 현 상태가 바뀌어서 더 이상 유효하지 않아서 폐기되어야 할 수가 있다. 그래서 변화가 잦고 미래를 알 수 없는 프로덕트의 초창기에는 문서를 만들 시간에 일을 더 하는 쪽으로 프로젝트 작업들이 진행을 하고 있었다.</p>
<p>결과론적인 이야기이지만, 문서 관리가 어려우면 문서의 양을 압축해서 최소한으로라도 문서화를 해둘 수는 있지 않았을까, 생각해본다.</p>
<h4 id="1-c-서비스-기능-별-정책">1-c. 서비스 기능 별 정책</h4>
<p>프로덕트에 기획/서비스 관점이 부족했던 시절에는 각 기능에 대해서 명세라고 할만한 것이 부족했다. 명세가 부족했다는 것은 명세에 대한 정책을 제대로 정하지 못했다는 것으로 보였다. 서비스 기능에 대한 정책이 뾰족하지 못하다 보니 똑같은 기능이라도 누구랑 커뮤니케이션을 하느냐, 언제 커뮤니케이션을 하느냐에 따라 종종 명세가 미묘하게 달랐다.</p>
<h4 id="1-d-서비스-영업을-위해-필요한-제품-설명-및-어필">1-d. 서비스 영업을 위해 필요한 제품 설명 및 어필</h4>
<p>프로덕트를 열심히 만들어도 서비스 영업에 필요한 부분을 어필을 못하면 제품이 성장을 못할 것 같다. 기획/서비스 관점이 부족하던 시절에는 프로덕트를 홍보할 때 ‘이 기능이 무엇이다, 이렇게 쓰는 것이다, 이런 의미가 있다’를 서비스 관점에서 제대로 이해해서 어필까지 하기가 더 어렵지 않았을까 싶다.</p>
<hr>
<h3 id="2-기술적-도구-방법">2. 기술적 도구, 방법</h3>
<p>인프라 모니터링 서비스, 헬스체크 같은 서비스부터 프로그래밍 언어, 디비 언어 같은 것들을 모두 기술적 도구라고 해보자. 똑같은 기술적 도구라도 더 깊이 알 수록, 그리고 기술적 도구들을 여러 가지 다룰 줄 알 수록 업무를 처리하는 효율성과 효과에서 큰 차이를 보이는 것을 자주 확인하고 있다.</p>
<h4 id="2-a-인프라-모니터링-서비스">2-a. 인프라 모니터링 서비스</h4>
<p>인프라 모니터링 서비스를 도입한 후의 서비스 안정성과 효율성은 전과 비교가 되지 않을 정도로 좋아졌다. 데이터 기반 의사결정은 비즈니스 레벨에만 있는 것이 아니라는 것을 몸소 느낄 수 있었다. 과거에는 문제를 찾고 개선할 방법을 찾는 방법이 고객의 직접적인 요구사항이나 피드백, 또는 실제 서비스 환경과 다른 모의실험을 해보거나, 또는 추측이나 상상을 해보는 것이었다. 그런데 모니터링 서비스를 도입한 이후로는 며칠 몇 시 몇 분에 고객이 서비스를 어떻게 어떤 빈도로 사용하고 있는지, 시간에 따라 어떤 차이가 있는지를 수치로 볼 수 있기 때문에 어떤 점이 문제이고, 개선할 수 있는지를 데이터로 파악해서 논의해볼 수 있었다.</p>
<h4 id="2-b-orm과-sql">2-b. ORM과 SQL</h4>
<p>ORM이 SQL로 어떻게 번역이 되는지, 거꾸로 SQL을 어떻게 ORM으로 작성하는지에 대한 이해도가 높아질수록 언어적인 표현력도 좋아지고 종종 서버와 디비의 리소스를 절약할 기회를 많이 찾을 수 있었다. 예를 들어, 땡땡문고(ttaengttaengmungo)의 2020년 지점별 및 월별 출간 도서 권수를 알고 싶으면 아래처럼 로우쿼리를 작성할 수 있을 것이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">
<span style="color:#66d9ef">SELECT</span> DATE_FORMAT(published_date, <span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#f92672">%</span>y<span style="color:#f92672">-%</span>m<span style="color:#960050;background-color:#1e0010">’</span>) pub_date, <span style="color:#66d9ef">location</span>, <span style="color:#66d9ef">count</span> <span style="color:#66d9ef">FROM</span> ttaengttaengmungo
<span style="color:#66d9ef">WHERE</span> published_date <span style="color:#f92672">&gt;=</span> <span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#ae81ff">2020</span><span style="color:#960050;background-color:#1e0010">’</span> <span style="color:#66d9ef">AND</span> published_date <span style="color:#f92672">&lt;</span> <span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#ae81ff">2021</span><span style="color:#960050;background-color:#1e0010">’</span>
<span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> DATE_FORMAT(published_date, <span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#f92672">%</span>y<span style="color:#f92672">-%</span>m<span style="color:#960050;background-color:#1e0010">’</span>)

</code></pre></div><p>이 로우쿼리를 ORM으로 만든다면 아래처럼 할 수 있을 것 같다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">*</span> DATE_FORMAT_FUNC : A custom <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">for</span> SQL function<span style="color:#f92672">.</span> Refer to django<span style="color:#f92672">.</span>db<span style="color:#f92672">.</span>models<span style="color:#f92672">.</span>Func

ttaengttaengmungo<span style="color:#f92672">.</span>objects<span style="color:#f92672">.</span>filter(
    published_date__gte<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">’</span><span style="color:#ae81ff">2020</span><span style="color:#960050;background-color:#1e0010">’</span>,       
    published_date__lt<span style="color:#f92672">=</span><span style="color:#ae81ff">2021</span>
)<span style="color:#f92672">.</span>values(
    <span style="color:#960050;background-color:#1e0010">‘</span>location<span style="color:#960050;background-color:#1e0010">’</span>
    pub_date<span style="color:#f92672">=</span>F(DATE_FORMAT_FUNC(<span style="color:#960050;background-color:#1e0010">‘</span>published_date<span style="color:#960050;background-color:#1e0010">’</span>, Value( <span style="color:#960050;background-color:#1e0010">‘</span><span style="color:#f92672">%</span>y<span style="color:#f92672">-%</span>m<span style="color:#960050;background-color:#1e0010">’</span>),
    output_field<span style="color:#f92672">=</span>CharField()))<span style="color:#f92672">.</span>annotate(
    count<span style="color:#f92672">=</span>Count(<span style="color:#960050;background-color:#1e0010">’</span>pub_date<span style="color:#960050;background-color:#1e0010">’</span>)
)

</code></pre></div><p>일단 디비에 쿼리를 해서 데이터를 가져오면 추가 조작이 필요할 때 다시 디비 쿼리를 해야 하거나, 코드 레벨에서 추가 조작을 해야 하기 때문에 디비 부하나 서버 부하를 늘리게 된다. 그래서 가능하면 추가적인 연산을 하지 않도록 필요한 데이터만, 적절히 포매팅을 한 상태로 가져오는 게 좋을 것으로 보인다. 물론, 트레이드오프를 고려해서!</p>
<p>ORM을 이용한 최적화에서 prefetch_related의 힘을 제대로 확인할 수 있기도 했다. prefetch_related는 1:N의 쿼리가 필요한 상황에서 추가적인 쿼리를 통해 미리 데이터를 캐시 하는 기능으로 이해를 하고 있는데, 특정 (where) 조건의 쿼리를 커스터마이징 할 수도 있다는 사실에 놀랐다.</p>
<h4 id="2-c-컨테이너라이징">2-c. 컨테이너라이징</h4>
<p>사실 개발하고 모니터링 관점에서 보았을 때에 컨테이너라이징 전후의 차이를 체감하는 일이 많지는 않았다. 그렇지만 인프라 레벨에서 큰 변화라는 것을 알고 있다. 컨테이너 환경과 아닌 환경은 관리성, 호환성, 확장성, 리소스 절약 측면에서 큰 차이가 있다고 한다.</p>
<p>예를 들면, 컨테이너 없이도 서버에서 서비스를 프로세스로 띄워 제공할 수 있고, 스케일링도 가능하지만 컨테이너 환경이 없으면 서버 별로 다른 구성, OS 별, OS 버전 별 미묘한 차이들로 인해서 서비스에 차이가 생기는 이슈들을 수동으로 매번 맞추어야 하기 때문에 통제하기가 어렵다. 컨테이너라이징은 애플리케이션을 제공하기 위한 환경을 자동화해놓는다는 뜻이기도 하므로 이런 문제를 해결해준다.</p>
<p>또한, 서버에 nginx, 웹서버 게이트웨이 등등의 각 서비스를 프로세스로 띄우면 특정 서버에 종속되어 있지만 컨테이너 환경(팟 환경)에서는 서버의 용도를 특정하지 않아도 자유롭게 서비스를 실행할 수 있다.</p>
<h4 id="2-d-레이턴시-모니터링">2-d. 레이턴시 모니터링</h4>
<p>헬스체크 서비스와 인프라 모니터링 서비스를 도입하면서 레이턴시 모니터링 역시 가능해졌다. 서비스의 속도는 고객 만족도와 리소스 절약에 직결되는 부분으로 알고 있다. (* 실제 실험 결과를 인용하면 좋겠지만 아쉽게도 찾지 못해서 대신 책의 내용을 인용해서 정리하면, ‘구글 엔지니어에게 듣는 네트워킹과 웹 성능 최적화 기법’이라는 책의 1장 처음에는 ‘웹사이트가 빠를수록 사용자가 더 오래 머물고, 재방문하고, 구매전환율이 높아진다’는 연구결과가 있다고 한다.) 날짜 별로 기능별 레이턴시를 정리해보면서 날짜별/기능별로 특별히 차이가 있는 부분들, 병목이 되는 부분들, 개선이 된 부분들을 확인하면서 점점 서비스가 고도화되는 것을 직접 수치로 확인할 수 있었다.</p>
<hr>
<h3 id="3-협업-문서에-대한-정리">3. 협업 문서에 대한 정리</h3>
<h4 id="3-a-작업-단위별-스케줄-및-진행상황-문서">3-a. 작업 단위별 스케줄 및 진행상황 문서</h4>
<ul>
<li>해야 하는 작업을 단위별로 쪼개서 각각을 스케줄로 작성하고 거기 서 또 각각에 대해서 진행상황을 세분화해서 표기하는 문서</li>
<li>매니저, 기획자가 실무자의 작업을 가시적으로 파악 가능. 다음 계획을 잡기에 용이함</li>
<li>실무자 간 협업을 할 때, 작업 의존성이 있는 부분을 미리 완성할 수 있도록 조율할 수 있음. 작업 의존도를 고려해서 작업 단위 별로 작업을 마칠 때마다 협업하는 동료에게 전달하면 전체 작업 속도 향상</li>
</ul>
<h4 id="3-b-기술-이론-배경-문서">3-b. 기술 이론 배경 문서</h4>
<p>⁃ 같은 직군의 동료와 기술 리더에게 초기 기술 디자인을 공유, 필요시 작업 방향을 컨펌 받고 일부는 방향을 수정함으로써 미스커뮤니케이션을 줄일 수 있음</p>
<h4 id="3-c-기획--기능--디자인-스펙-문서">3-c. 기획 &amp; 기능 &amp; 디자인 스펙 문서</h4>
<ul>
<li>프로젝트에 관여하는 모든 동료와 공통된 기획, 기능, 디자인 스펙을 논의하여 해당 프로젝트에 대한 아이디어를 일치시킬 수 있음. 하이레벨에서의 의사결정 통합</li>
</ul>
<h4 id="3-d-기술-스펙--아키텍처-문서">3-d. 기술 스펙 &amp; 아키텍처 문서</h4>
<ul>
<li>협업하는 기술자 간 긴밀하게 협업을 하기 위한 용도</li>
<li>작업 단계에서는 기술 스펙과 아키텍처가 자주 바뀌는데, 실제로 구현하고 공유하면 시간이 오래 걸릴 수 있고 작업 수정 시 비용이 커짐, 문서를 통해 스펙과 아키텍처를 일치하도록 싱크 하면서 작업하면 작업의 속도와 완성도를 같이 높일 수 있음</li>
</ul>
<h4 id="3-e-api-스펙-명세-문서">3-e. API 스펙 명세 문서</h4>
<p>⁃ API 레벨에서 어떤 리소스가 존재하고, 어떻게 데이터를 요청해야 하고, 응답받는지를 설명하는 용도</p>
<h4 id="3-f-api-별-실제-요청응답-데이터-예제-문서">3-f. API 별 실제 요청/응답 데이터 예제 문서</h4>
<p>⁃ 실제로 데이터 요청에 따른 응답은 여러 가지 케이스가 가능한데, API 스펙 명세 만으로는 이것을 알 수 없어서 예제 문서가 있으면 협업에 도움이 됨</p>
<h4 id="3-g-qa-문서">3-g. QA 문서</h4>
<p>⁃ 기능을 UI에 드러나는 것만 보고 파악하기에는 무리가 있음. 왜냐하면 기능이 동작하는 기술적인 원리는 보이지 않기 때문. 그래서 브라우저 사이드/클라이언트 사이드에서 어떤 테스트를 수행해야 하는지를 업무와 관련된 동료들이 이해할 수 있게 문서를 작성해두는 것이 도움이 됨</p>
<h4 id="3-h-직접-대화하기">3-h. 직접 대화하기</h4>
<p>⁃ 아무리 채팅을 하고 문서를 공유해도 전달되지 않거나 해결하지 못하는 부분들이 생길 수밖에 없음. 이런 부분을 직접 대화를 나눠보면 동료 간 작업 상태 체크, 이슈 체크, 멘탈 체크, 해야 할 일을 체크할 수 있음</p>

  </div>
</div>

        <span id="typed"></span>
      </div>
    </div>

    
    
    
    
    
    
    
    
    
    
    
    
    
  </body>
</html>

