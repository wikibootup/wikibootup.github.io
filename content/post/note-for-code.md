+++
date = "2017-10-05T15:40:09+09:00"
title = "코드를 위한 노트"
draft = false
categories = []
tags = ["code", "programming", "essay"]

+++

> 큰스님은 황급히 코로 손을 가져갔다. 손에 닿은 것은 어젯밤의 짧은 코가 아니었다. 윗입술의 위쪽부터 턱밑까지 대여섯 치나 늘어져 있던, 옛날의 기다란 코였다. 큰스님은 코가 하룻밤 새 다시 원래대로 길어졌다는 것을 알았다. 그리고 그와 동시에 코가 짧아졌을 때와 마찬가지로, 홀가분한 기분이 어디선지 모르게 되돌아온 것을 느꼈다.[^1]

## 두 연산의 비교
아래 두 연산이 있다. 컴퓨터는 둘 중 어느것을 더 빠르게 처리할까?

1. ( 9,223,372,036,854,775,807 > 9,223,372,036,854,775,806 )
2. ( 2 > 1 )

나의 예상으로는 사람들은 '당연히 2번'이라고 생각하거나 '당연히 똑같을 것'이라는 답변 가운데 하나를 낼 것 같다. 전자로 답한 사람은 자기를 컴퓨터에 대입시켰을 가능성이 크다. 그 사람은 '내 머릿 속에는 당연히 2번이 빠르게 계산되었으니 컴퓨터도 2번이 빠를 것'이라는 사고의 흐름을 거쳤을 것이다. 전자가 그렇다면, 후자로 답한 사람은 64bit CPU를 생각했을 것이다. 그 사람은 '어차피 64bit이하의 값을 한 번에 처리하기 때문에 두 연산의 속도차이는 없을 것'이라는 사고의 흐름을 거쳤을 것이다. 만약 '당연히 2번'이라고 대답한 사람에게 다른 이유가 있다면, 그 사람은 '대소비교'의 방법을 따졌을 것이다. 그 사람은 '하드웨어가 최상위 비트에서부터 값을 비교한다면 2번이 더 빠를 것'이라고 생각할 가능성이  있다. 결론적으로 나는 '당연히 똑같을 것'이라고 생각한다. 그 이유는 '당연히 2번'의 가정은 '64비트 컴퓨터가 64비트 이하의 데이터를 한 번에 처리할 수 있다'는 사실 아래 모순이 되기 때문이다.

위와 완전히 같은 선택지를 두고 사람들 간에 논쟁을 할 가능성은 적지만 위와 비슷한 경우는 꽤 많다. 전제가 틀린 논리, 성급한 일반화의 오류, 또는 빠뜨린 가정 등을 적절하게 판단할 수 있어야 한다. 그리고 자신이 올바르게 판단했다는 확신이 있더라도 상대의 감정이 상하지 않도록 유려하게 전달하면 더 높은 수준의 논의를 이끌어낼 수 있을 것이다.

## 자료형Data type
흔하게 사용하는 자료형이라는 말은 나에게는 왠지 수체계와 관련이 있는 것처럼 느껴지기도 했다. 왜냐하면 정수, 실수처럼 자료형 역시 어떤 기준의 집합이기도 하기 때문이다. 하지만 명확히 다른 점은 자료형이 수체계인 것이 아니라 그것을 표현하기 위한 구분을 하는 것이라는 점이다. 그리고 수체계에서는 실수가 자연수를 포함하는 관계이지만, 컴퓨터에게 실수형Float과 정수형Integer은 그 자체로는(호환적인compatible 연산을 정의하지 않는다면) 집합적으로나 연산적으로나 아무 관계가 없다. 요약하면, 자료형은 데이터를 분류하는 식별자identifier이다.

c언어를 배운 사람들 가운데에는 흔히 Char 타입이 1Byte의 크기를 가진다고 알고 있는 사람들이 있을 것이다. 이 말은 반은 맞는데 반은 틀렸다. Char 타입이 1Byte의 영역 내에서 그 정보가 수정되는 것은 사실이나, 할당 받는 메모리의 크기는 컴퓨터 구조에 따라 다르다. 포인터 연산을 해보면 Char 타입으로 정의된 메모리 공간을 이동할 때에 1Byte보다 많이(예를 들면 4Byte 씩) 이동하는 것을 본 적이 있을 것이다. 데이터의 정보 크기와 실제 할당 메모리의 크기가 다를 수 있다는 사실을 모르고 있다면, 명시된 자료형의 크기와 실제 할당된 메모리의 크기의 차이를 스스로 합리화하기는 어려울 것이다.

자료형을 데이터를 분류하는 식별자identifier라고 정의한다면, (1) 첫째로, 다양한 종류의 식별자를 자료형으로 지정할 수 있다. 예를 들어, c언어라면 구조체를, 객체지향 언어라면 클래스를 자료형을 판단하기 위한 식별자로 지정할 수 있을 것이다. (2) 그리고 둘 째로, 자료형을 데이터의 흐름을 제약하기 위한 수단으로 사용할 수 있다. 함수형 언어라면 보다 간편하게 수식처럼 데이터의 흐름을 시그니처로 정의할 수 있을 것이다. 아래는 그 예시이다.[^2]

```haskell
type Name = String
type Grade = Int
type StudentGrade = [(Name, Grade)]

studentGrade :: StudentGrade
studentGrade = [ ('Robert', 99) ]

isInStudentGrade :: Name -> Grade -> StudentGrade -> Bool
```

'자료형을 느슨하게 제약하는 언어'는 코드 작성자보다는 검토자와 개선자(리팩토링을 하는 사람)가 고통을 받을 가능성이 높고, '자료형을 엄격하게 제약하는 언어'는 코드 작성자가 가능한 재앙을 방지할 수 있을지도 모른다. '자료형을 느슨하게 제약하는 언어'로 작성된 코드는 근본적인 설계상의 취약점을 가지는 것은 아닐까? 하지만 꼭 그런 것은 아니다. '자료형을 느슨하게 제약하는 언어'를 사용하는 사람들은 자료형을 제약할 필요가 있을 때 그 자료형을 검사(Checking Type)하는 유연한 방법을 장점으로 생각할 수도 있기 때문이다. 이것은 '보통'의 경우에는 '자료형의 느슨한 제약'이 문제를 일으키지 않고, '특수한' 경우에는 코드 작성자가 명시적으로 그 자료형을 제약하는 방법을 성공적으로 구현할 수 있다는 것을 전제로 한다. 또한 작성해야 할 코드가 한 번 작성하면 끝이 아니라 계속해서 개선해야 한다면 스크립트 언어가 장점이 될 수 있다.

## 리팩토링
마틴파울러는 그의 저서 <리팩토링>에서 가장 중요한 것은 '메서드 추출Extract method'라고 했다. 메서드 추출이란 여러 기능이 복합적으로 이루어져 있는 메서드를 여러 다른 메서드로 추출하여 원래의 메서드에서 추출된 메서드를 호출하는 구조로 만드는 것이다. 그가 이것을 가장 중요하게 생각한 이유는 아마도 이것으로부터 리팩토링이 시작하기 때문일 것이다. 메서드 추출이 선행되어야 기능들이 명확하게 분리된 메서드를 만들 수 있고, 그렇게 되어야 메서드를 명확하게 설명하는 이름을 지을 수 있다. 그 다음부터 메서드의 파라미터를 받는 방식, 내부적으로 인자를 전달하는 방식 등을 리팩토링하는 것이다. 이 책은 당연하게 보이는 것들도 하나 하나 주제를 나누어 자세히 설명을 한다. 덕분에 사소하다고 생각되어 개선하지 않는 코드 역시 리팩토링을 해야하는 대상임을 다시 확인하게 된다.

'리팩토링'을 읽고 마틴파울러같은 동료들만 있는 곳에서 일하고 싶다는 생각이 든다면, 산드로 만쿠소의 <'소프트웨어 장인', 길벗, 2015.9>에는 '레거시 코드'와 관련하여 설명한 글을 읽어보자.

> '오래전에 떠나버린 개발자가 남겨놓은 코드 위에서 일하는 상황이라면 개발자가 위축될 수밖에 없다. 아무런 테스트도 없고 문서도 없다면 공황에 빠진다. 하루 하루가 한탄과 푸념으로 채워지고 우울해지기 십상이다. 당혹감에 빠지는 것이 일상이 되고 직장이 싫어지기 시작한다. 더욱 나쁜 일은 직장을 바꾼다고 해도 큰 도움은 안 된다는 것이다. (...) 서로 다른 회사나 프로젝트들에 따라 다른 점은 단지 빠져 있는 구렁텅이의 깊이가 얼마나 깊느냐의 차이뿐이다.'

이 산전수전 다 겪어본 개발자는 이어서 이렇게 말한다.

> '보는 것 자체가 막막하기만 한 코드를 이해하려 든다는 것이 처음에는 무모할 수 있다. 작은 부분씩 집중해서 하나씩 이해해 나간다면 조금씩 개선이 가능하다. (...) 레거시 코드로 일하는 것은 거대한 직소 퍼즐을 푸는 것과 비슷하다. (...) 각 조각을 그룹으로 나누고 모서리나 경계선부터 시작해야 한다. (...) 각각의 작은 그룹들에 대해서 조금씩 조각을 맞춘다. (...) 몇몇 조각들을 맞추는 데 성공하면 전체 그림의 일부분을 볼 수 있다. (...) 코드의 중요 부분이 안정화되면(테스트 코드로 검증되고, 과도한 종속성이 해소되고, 역할이 제대로 정의되는 등) 사용하고 싶었던 새롭고 멋진 프레임워크를 도입하는 것이 가능할 수도 있다.' <'Page 143, 144'>.

'리팩토링'을 읽고 잠깐 붕 뜬 손이 곧 현실감각을 되찾고 키보드로 내려올 것이다.

<'소프트웨어 장인'>에는 다음과 같은 구절도 나온다.

> '비범한 개발자는 요구사항을 충족하는 가장 단순한 코드를 만들어 경험이 적은 개발자가 이해하는 데 아무런 문제가 없도록 한다. (...) 가장 훌륭한 코드는 작성할 필요가 없는 코드다.'

그리고 그 다음 단락에서는 코드로 영역을 넓혀 설명한다.

> '잘 작성된 코드는 단순하고, 작고, 테스트 가능하며 이해하기 쉽다. 그리고 가장 중요한 부분으로 코드가 해야 할 일을 해낸다. 코드는 버그와 고통의 근원이다. 더 적게 작성할 수록 더 좋다.' <'Page 300, 301'>.

별 말 아닌듯 단순하지만 나는 이 두 단락이 정말 명쾌하게 코드가 어떠해야 하는지를 설명하고 있다고 생각한다. 단어 선택도 마음에 든다. 평범함은 말 그대로 흔하기 때문에 평범한 것이다. 그리고 비범함은 흔치 않은 것이기에 소중하다.

Lint: Lint 역시 리팩토링의 일부로 볼 수 있을까? 코딩 스타일 가이드를 적용하고 그것대로 코드를 제약하 것이 Lint라고 한다면 사소하기는 해도 Lint를 적용하는 것이 리팩토링의 일부일 수도 있을 것 같다. Code lint에 있어서 논쟁에 가까운 논의를 하는 부분은 의외로 사소한 부분들이다. 만약 당신이 Lint의 중요성을 인지하고 있더라도 그 논의의 주제에는 놀라울 만큼 사소한 것들이 많다는 것을 알고 있을 것이다. 예를 들어, 가로줄의 길이와 새 줄(New line)을 만드는 규칙을 논의할 때에는 (1) '가로줄에 몇개의 글자가 있을 때 줄바꿈을 하는 것이 적절한가?', (2) '가로 한 줄로 표시하기에 적절한 연산 개수나 객체 필드의 개수는 몇개일까?'와 같은 논의사항들이 있다. 이 문제가 실제로 중요한 것이라고 전제할 때에도, 이것을 위한 논쟁에 시간을 많이 쏟아야 한다면 이것은 중요한 문제는 아니다. 왜냐하면 Code lint는 오로지 코드를 작성하는 목적을 위한 수단으로 성취할 수 있을 때 가치가 있기 때문이다. 조금만 더 풀어서 설명하면, Code lint의 목적은 (a) 작성한 코드의 문법적 오류 인지와 더불어, (b) 사람이 코드를 볼 때 읽고 파악하는 것(가독성, 판독성, 일관성)을 더 용이하게 만들어 궁극적으로는 코드를 작성하는 것을 더 정확하고 빠르게 만드는 것이다. 따라서 논쟁을 하는 구성원 각각은 논쟁이 좀처럼 끝나지 않는 경우 그것이 기회비용으로 시간을 지불할만큼 가치있는 주제인지를 판단해야 한다.

## 디지털공학
공학도들은 디지털공학을 배우면서 처음으로 물리와 아날로그로의 세계로부터 탈출한다. AND, OR, NOT을 조합하여 다양한 것들을 만든다. (1) NAND, NOR, XOR을 만들고, (2) 엔코더 - 디코더, MUX - DEMUX를 만들고, (3) 피드백 루프가 존재하는 플립플롭을 만든다. 또한 플립플롭들을 조합하여 가산기를 만들어보면서 '기억과 연산'이 어떻게 이루어질 수 있는지에 대한 하나의 가능성을 확인한다. 이 과정에서 플립플롭들이 CPU 캐시, 레지스터, SRAM을 이루는 구성요소라는 것을 인지하게 된다. 여기에 이르면 말단terminal 게이트 하나가 비트 하나라는 사실로 이어지면서 끝이난다.

2의 보수: 한편, 나는 1의 보수와 2의 보수라는 개념을 처음 보고 이해하지 못했다. 음수를 표현하기 위하여 왜 '이런 짓'을 하는지 몰랐다. 왜 원래의 비트값을 그보다 더 큰 2의 제곱수(최상위 비트만 set, 나머지가 clear)로 빼준 뒤(1의 보수), 거기에 1을 더하는 작업(2의 보수)을 하는 것일까? 나의 이런 의문은 우연히 발견한 아날로그 시계의 비유를 보고 나서야 제대로 풀릴 수 있었다. ( 이걸 보고 이해했다는 것이 더 이상하게 느껴질지도 모르겠다. ) 이 방법은 시계의 시분침을 생각해보는 것이다. 여기서 양수는 AM이고, 음수는 PM으로 가정한다. 12시 59분을 생각해보자. 여기서 1분을 더하면 시분침은 0시 00분의 위치와 같다. 이때 12시 60분을 PM으로 만드는 자리올림수라고 판단하면, 12시 60분은 PM 0시 00분이 된다.

## 컴파일러
컴파일러는 코드를 식별, 분석, (기계어) 생성하기 위한 코드(프로그램)이다. 연산은 최하위에서 시작하여 최상단까지 이루어지며 결합하는 것이기 때문에 상향식 파서는 그런 계층 구조를 가지는 경우에 적합하다. 마치 사람이 정수의 사칙연산을 할 때, 1의 자리수부터 셈을 하는 것과 같은 것이다. 상향식 파서는 처음에는 코드를 하향식으로 내려가며 식별한다. 예를 들면, 각 키워드마다 '함수인가, 파라미터인가, 변수인가, 연산기호인가'를 판단한다. 이런 키워드 하나하나가 노드가 된다. 마침내 파서가 최하위 노드에 도달하면 그때부터 본격적인(어쩌면 하향하는 과정에서 간단한 연산을 했을지도 모른다) 연산을 진행한다. 흥미로운 것은 단순히 상수나 변수의 사칙연산 뿐 아니라, 연산의 주체와 대상이 가진 타입이 호환적인 경우 그것을 적절히 변환할 수도 있다는 점이다. 예를 들어, 배열 타입과 포인터 타입 간 연산은 배열 타입을 포인터로 바꿔버리고 수행할 수가 있다. 이렇게 노드를 만들어 연결한 뒤, 연산을 하는 작업은 키워드를 식별하고 분석하기 위한 구조체와 레퍼런스(포인터)를 만들어 재귀적으로 최하위 노드까지 호출한 뒤, 연산을 진행한 결과를 상향식으로 최상단 노드까지 반환하며 결합하는 식으로 이루어진다.

정적-동적 : 컴파일러 방식의 언어는 컴파일을 하여 실행파일을 만든다. 그 과정은 c언어로 보면, '전처리 - 컴파일 - 어셈블러 - 링커'가 될 것이다. 링크 작업이 완료되면 실행파일이 만들어진다. 즉, 프로그램의 코드를 한 줄이라도 수정하면 최소한 수정된 코드가 담긴 파일 1개를 다시 컴파일해야 한다. 이와 다른 방식인(반대방식은 아니다) 인터프리터 방식의 언어는 실행파일을 만드는 일련의 과정없이 그냥 코드를 한 줄 단위로 식별-분석-생성하여 바로 바로 실행한다. 수정이 빈번하면서 속도가 큰 영향을 미치지 않는다면 스크립트 언어가 좋은 선택일 수 있다. 그리고 그 반대의 상황에서는 컴파일 언어가 좋은 선택일 수 있다. 또한 컴파일 방식의 언어라도 자동 빌드-실행이 적절히 되고, 거기서 별 다른 지연(개발-상용 환경 모두에서)이 발생하지 않는다면 그것을 사용하는 것이 좋은 선택일 수 있다.

## 운영체제
프로세스 : 프로세스가 하는 작업이 내부적으로는 스케쥴러의 우선순위에 의해서 선택된 PCB라는 구조체를 조작하며 연산을 수행하는 과정으로 보인다. 스케쥴러에 의해서 프로세스들의 처리 순서가 정해져 있다. 각 프로세스는 저마다 제한 시간(제한된 클럭 수)이 있고, 그에따라 각자가 프로세서를 선점할 수 있는 시간이 정해져있다. 만약, I/O 이벤트를 기다려야 하는 경우에는 제한 시간이 남아있어도 프로세스는 블록되어 버린다 ( 선점할 수 있는preemtive 스케쥴러를 전제 ).

쓰레드 : 한편, 쓰레드 자체는 프로세스의 실행단위(PC가 실행하는)라고 볼 수 있다. 멀티 쓰레드 환경에서 프로세스는 쓰레드들이 공유하는 자원(Heap, Code, Static)의 단위로써 의미를 가지고, 각 쓰레드는 별도의 레지스터와 스택을 가지고 연산을 수행한다. 쓰레드가 곧바로 병렬 실행을 의미하는 것은 아니다. 하지만 멀티쓰레딩이 효과를 보려면 멀티 코어를 활용해야 하는 것 같다. 그 이유는 멀티 쓰레딩을 싱글 코어에서 한다면 각 쓰레드를 위한 컨텍스트 스위칭 작업이 오히려 총 연산속도를 더 느리게 만들 수 있기 때문이다. 따라서 멀티코어 환경이어야만 각 쓰레드가 개별 코어에 1:1로 할당되어 연산을 병렬적으로 수행할수 있을 것이다. 이 때 각 쓰레드의 연산이 다른 쓰레드의 연산에 영향을 미치는 경우(종속적인 경우)가 많을 것이므로 쓰레드 간 작업의 동기화를 해주어야 할텐데, 실무적으로 이런 문제들은 어떻게 해결할 수 있는지 궁금하다.

메모리 : 가상 주소라는 말은, 그것이 실제 하드웨어의 주소가 아니기 때문에 지어졌다. 가상 주소는 페이지나 세그먼트처럼 메모리를 블록 단위로 쪼개서 번호와 주소값을 가지고 있는 영역을 가리키는 일종의 매핑 테이블이다. 가상 주소는 페이지 또는 세그먼트를 가리키고, 페이지 또는 세그먼트는 실제주소를 가리킨다. 페이지의 경우를 먼저 생각해보자. 페이징은 메모리를 균등한 크기로 나눈 뒤, 페이지 번호로 관리하는 방법이다. 페이지 번호 필드(비트) 외에 '오프셋'이라고 불리는 필드의 크기(비트 수)가 곧 페이지의 크기를 나타낸다. 예를 들어, 페이지가 1K byte라면 10비트가 오프셋 비트로 할당되어 있을 것이다. 그렇다면 드는 궁금증은 32비트 필드로 큰 페이지를 표시하는 방법인데, 이것을 가능하게 하기 위해서 운영체제에는 오프셋 비트를 제외한 나머지 비트를 1/n으로 나누어 페이지를 n 단계로 계층화하는 방법이 이용된다. 페이징 과정을 이론적으로 직접 계산해보면 헷갈리는 부분이 많다. 한편, 세그먼테이션은 페이징과 비슷하지만 메모리의 크기를 작성자나 컴파일러가 정해서 분할하게 만들 수 있다는 점이 가장 큰 차이점이다.

운영체제를 이론적으로 배우는 관점과, 실제로 만드는 관점은 정말 많이 다른 것 같다. 간단해보이는 것도 직접해보면 많은 시간이 필요하고 그 시간의 대부분은 디버깅으로 이루어진다. 예를 들면, 부팅 중에 리얼모드와 보호모드에서 각각 콘솔창에 간단한 문자를 입력하는 것은 브라우저의 개발자도구를 열어서 문자를 출력하는 것과 비교도 안되게 어렵다. 고급언어라면 연산을 위하여 임의로 변수를 만들거나, 함수를 만들 수 있겠지만( 그것도 목적에 부합하는 명확한 이름으로 ), 어셈블리어로는 위처럼 간단한 연산도 다음 설명처럼 특수목적으로 만들어진 레지스터들을 오밀조밀 조합해야만 할 수 있다. '비디오 메모리에 접근(es를 해당 위치로 이동)하여 저장해둔 문자열의 각 문자를 cx를 이용하여 bx의 인덱스를 세가며count 출력한다. 이 때 bx는 2씩 이동해야 할 것이다. 왜냐하면 문자는 2바이트의 크기를 가지기 때문이다.' 보다시피 레지스터들이 하나의 역할만 하는 기계(또는 변수)로 구성되어 있는 대다가 그것을 조작하는 방식과 그것이 위치해야 하는 장소도 고정되어 있어서, 생각하는 대로 만들기 어렵다.

응용프로그램(커널 프로그램이 아닌)을 다루는 입장이라면 운영체제에 대해서 거의 모른다고 해서 이것때문에 직접적으로 장애가 생길 가능성은 많지 않을 것이다. 하지만 코드에 관한 배경지식을 넓히는 관점이라면 운영체제를 '코드적으로' 들여다 보는 것이 어느정도 도움이 될 것 같다. 실무적 관점(피말리는 디버깅을 포함한)을 제외하고서라면 '코드적으로 들여다보는 운영체제'는 코드 작성자가 교양으로 삼을 수 있을 것같다 ( 운영체제 앞에 '코드적으로'를 형용사로 붙인 이유는 '이론적으로는 그럴싸한데, 실무적으로는 의미가 떨어지는 이론들도 많다는 생각이 들어서'이다 ).

## 비동기 프로그래밍
커널 내부에서 이루어지는 인터럽트(I/O 등으로 인한)에 의해서 프로세스가 블록되고 컨텍스트 스위칭이 되는 작업이 이벤트 기반의 비동기 프로그래밍은 그것이 '사용자 수준의 작업과 커널 수준의 작업'이라는 차이를 제외하면 피상적으로 비슷해보인다.

자바스크립트의 경우에는 비동기 작업 가운데 동기화된 작업을 처리하는 방법이 여러가지가 있다. 기존 상용 서비스에서 이미 많이 사용되고 있는 것은 async 모듈과 promise 모듈로 보이고, 제너레이터, es7의 async/await 등은 '아직'인 것 같다. 이와 관련하여 인터넷에 좋은 자료가 많기 때문에 간략하게만 정리하려고 한다.

async 모듈의 경우에는 `async.series`, `async.each` 또는 `async.waterfall`이 자주 사용되는 것 같다. series, each의 경우, 중간 결과를 저장해둘 필요가 있다면, 상위 스코프에 변수를 선언하여 정의해야 한다. 필요에 따라서는 bind를 사용하여 함수가 콜백 이외의 인자들을 받을 수 있도록 해야한다. Waterfall은 이렇게 별도로 변수 없이 반환값을 인자로 받아서 사용하면 되어서 코드를 깔끔하게 작성하기에 좋지만 변수가 많아지면 오브젝트로 묶어서 전달해야 하고, 폭포 맨 위에서 반환한 인자를 폭포 맨 아래에서 사용하는 경우에는 중간에는 안쓰는 인자를 계속 폭포 아래로 내려보내야 하는 단점 등이 있다.

promise 모듈은 동기화된 각 작업들에 대하여 $q처럼 reject으로 원래 예정된 다음 작업 대신 오류메시지를 담은 콜백을 리턴하고, resolve로 결과를 반환하며 다음 작업을 예정된 다음 작업을 진행한다. promise는 then을 이용하여 필요한 순서대로 작업을 동기화할 수 있다. async 모듈과 promise 모듈이 콜백의 깊이를 평평하게flatten 만들었지만 다소 복잡한 함수 흐름으로 그것을 구현했다면, 제너레이터와 async/await는 아예 동기 방식의 프로그래밍처럼 코드를 작성할 수 있도록 만들어버린다.

> 제너레이터는 프로세스가 루프를 순회하는 것을 제어하는 특수한 규칙이다 ( A generator is a special routine that can be used to control the iteration behaviour of a loop[^3] ).

제너레이터는 반복문의 각 루프를 함수들(반환값을 인자로 사용하는)로 만들어 배열이나 리스트처럼 연결해놓은 형태라고도 볼 수 있다. 제너레이터를 이용하면 Iterator가 순회하는 시점을 코드의 작성자가 제어할 수 있다. 제너레이터는 Stream interface와도 비슷한 면이 있다 ( 나는 과거에 Stream interface를 Python의 제너레이터로 흉내낸 적이 있다.[^4] )

비동기 프로그래밍에서 제너레이터는 순회를 효과적으로 하는 목적이라기 보다는, 비동기 작업이 포함되어 있으나 일반적인 동기식 코드처럼 순차적(동기적)으로 진행하는 스타일을 위해서 사용할 것으로 보인다. 예를 들면, 동기화가 필요한 곳에서 yield를 해당 작업(함수)과 함께 걸어두고, 필요한 작업이 수행되면 next를( 그 작업이 함수 내에서 이루어졌다면, 그 함수 내부에서) 실행하여 작업을 재개하는 방식으로 이용하는 것이다.

async/await는 generator와 promise를 이용한 문법적 설탕syntactic sugar으로 보인다. 단순히 동기 작업을 진행하는 함수에 대하여 async 키워드를 명시하고 yield를 await로 교체하면 async/await 방식으로 바꿀 수 있다.
위에서 내가 <리팩토링>에서 인용한 '메소드 추출', 그리고 <소프트웨어 장인>에서 인용한 '단순하고, 작고, 테스트 가능하며 이해하기 쉽게 만들어야 한다'는 것이 덩어리가 커지기 쉬운 동기화된 작업을 하는 데에 있어서 중요하다는 생각이 든다.

## 특이한 동기
게임을 좋아하는 것이(좋아했던 경험이) 긍정적인 영향을 줄 수도 있을까? 만약에 있다면 이런 것을 생각해볼 수 있다. 게임을 정말 좋아하는 사람들은 첫째로, 종종 자신이 플레이하는 게임이 이미 구성되어 있는 형식을 바꿔보는 상상을 하게 된다. 그런 상상 속에는 새로운 캐릭터, 지도, 악당, 아이템을 추가하거나 수정하는 것이 포함되어 있다. 그리고 둘째로, 게임의 플레이를 상상의 시뮬레이션으로 그려본다. 이 두가지 상상은 결국 시뮬레이션이 가능한 무언가를 만들고 싶은 충동으로 이어진다. 이런 충동은 단순히 돈을 버는 것, 명성을 쌓는 것과는 다른 특이한 동기를 만드는 것 같다.

## 교양 또는 필요조건
의존: 마치 패키지 여행을 온 관광객들이 여행 가이드의 계획에 따라 여행지의 명소를 찾아서 설명을 듣듯이, 신입생들은 다소 어벙한 표정으로 컴퓨터 수업을 듣고 있었다. 그게 7년 전의 일이었다. 당시 나의 주변에는 '코드에 대한 것'에 대하여 생각을 할 수 있는 사람들이 없었다. 나 역시 약간의 모험만 했을 뿐, 패키지 여행을 하고 있다는 것에서 그들과 동일했다. 나는 가이드의 통제를 따르고, 가이드의 설명에 의존했다. 이것은 그 당시에는 문제가 되지 않았다. 그러나 곧 문제가 될 부분이었다.

분석: 나는 '코드'가 이론적으로는 '수학적인 것'에 가까운데, 실무적으로는 '철학적인 것'에 '조금 더' 가깝다고 생각한다. 지속적으로 변화하는 기술과 비지니스적 요구사항, 그로인한 기존 체계의 붕괴 덕분에 아키텍처의 구조 및 코드의 진선미를 위하여 끊임없이 고민하고 논의를 해야한다는 점이 그렇다.

극복: 위에서 '운영체제'를 일종의 교양으로 보는 것에 대해서 언급했다. 만약, '교양'을 어떤 경지에 다다르기 위한 관점에서 바라본다면 이 문맥상에서는 적어도 '교양'을 '필요조건'이라는 말로 대체할 수 있을 것 같다. 마찬가지로 흔히 말하는 디자인 패턴, 알고리즘, 계산이론 등의 전문적 영역, 그리고 수학, 철학, 문학과 같은 기초 학문적 영역, 마지막으로 커뮤니케이션, 비지니스와 같은 현실적 영역 모두 나는 '그런 맥락에서의 교양이자 필요조건'으로 바라보고 싶다. 이런 사고방식을 이용해서 어느 하나가 필수적이라고 보는 편향 또는 맹목을, 반대로 어느 것도 필요하지 않다고 보는 회의나 허무주의를 피하고 극복하려고 한다.

[^1]: <라쇼몬, 아쿠타가와 류노스케 저, 서은혜 옮김, 민음사, 2014.10>
[^2]: Reference : http://learnyouahaskell.com/making-our-own-types-and-typeclasses - 'Type synonyms'
[^3]: [https://en.wikipedia.org/wiki/Generator_(computer_programming](https://en.wikipedia.org/wiki/Generator_(computer_programming))
[^4]: https://github.com/my-snippet/SICP/blob/master/backup/notebook/3-2-stream-interface.ipynb
