<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      UI코딩2: 컴포넌트와 테마 &middot; wikibootup
    
  </title>

  <script src="https://wikibootup.github.io/js/typed.min.js" type="text/javascript"></script>

  
  <link rel="stylesheet" href="https://wikibootup.github.io/css/app.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://wikibootup.github.io/assets/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://wikibootup.github.io/assets/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://wikibootup.github.io/atom.xml">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-93792142-1', 'auto');
  ga('send', 'pageview');

</script>


</head>


  <body>

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
  </div>
  <nav class="sidebar-nav">
    <a class="sidebar-nav-item " href="https://wikibootup.github.io/post">Posts</a>

    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </nav>

  <div class="sidebar-item">
    <p>Made by 
      <a href="https://twitter.com/mdo" target="_blank">@mdo</a>.
    </p>
    <p>&copy; 1. All rights reserved.</p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="https://wikibootup.github.io/" title="Home">wikibootup</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">


<div class="post">
  <span class="post-date">Jul 16, 2017</span>
  <h1 class="post-title">UI코딩2: 컴포넌트와 테마</h1>
  <div class="font-normal">
    <blockquote>
<p>기계적 창의성은 디자인 능력의 한 종류지만, 또한 개인의 소질이기도 하다. 헌신을 부추기는 도덕적 임무에 대한 동의 여부와는 별개로, 모든 사람이 다 그런 식으로 일할 수 있거나 그런 작업에 이끌리는 것은 아니다. 디자이너는, 자신이 디자인의 매우 넓은 범위 중 정확히 어디에서 제일 효과적으로 기여할 수 있을지 스스로 알아내야 한다.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
</blockquote>
<h1 id="개요">개요</h1>
<p>테마란 일상적인 의미에서는 대화(또는 작품의)의 주제나 화제를 뜻하고, 주식에서는 주가의 등락을 결정하는 요인이라고 부른다고 한다. 그렇지만 여기서는 이것을 &lsquo;<strong>브랜드를 표현하는 일관된 UI 스타일</strong>&lsquo;로 정의한다. 그리고 여기서의 &lsquo;컴포넌트&rsquo;는 &lsquo;<strong>웹페이지를 구성하는 기능적으로 구분된 시각적 사물</strong>&lsquo;로 그 의미로 한정하기로 한다. 정리하면 &lsquo;테마화가 가능한 UI 컴포넌트화&rsquo;란 &lsquo;웹페이지를 구성하는 기능적으로 구분된 시각적 사물들의 스킨(skin)을 브랜드에 따라 다르게 표현할 수 있도록 만드는 작업&rsquo;이다.</p>
<p>상상해보자, 누군가 맥주회사를 위한 UI 테마화를 원하고 있다. 이 경우 각 UI 요소는 M사이건 H사이건 상관없이 독립적으로 존재해야 하며, 오직 UI 스킨만이 테마에 따라 달라져야 한다. 그리고 각 UI 요소는 특정 뷰(웹페이지)에 독립적인 컴포넌트의 형태로 만들어야 한다. 만약 이를 무시하고 뷰(또는 웹페이지)에 UI 요소를 종속시킨 채로 테마화 작업을 진행한다면 뷰의 개수와 브랜드(M사, H사, 등등)의 개수가 늘어날 수록 추가작업량은 곱절로 늘어나게 될 것이다.</p>
<p>UI 요소가 컴포넌트가 되는 것과 더불어 그것이 테마에 따라 스킨을 달리할 수 있으려면 생각해야 할 것들이 많다. 웹사이트의 각 페이지마다 쓰이는 UI 요소가 특정 페이지에 의존적이지 않아 서로 다른 페이지에 공통적으로 쓰일 수 있도록 설계해야 함과 더불어 각  UI 컴포넌트 간에 가능한 조합은 어떤 것들이 있을지를 생각해야 하기 때문이다. 그리고 UI를 구성하는 기존의 방식이 전혀 컴포넌트를 고려하지 않았다면, 변화에는 적지 않은 고통이 따를 것이다.</p>
<p>내가 하고자 했던 것은 바로 위처럼 꼬일만큼 꼬여서 어쩔 수 없이 잘라내야 하는 실뭉치처럼 남겨진 기존의 구현물을 개선하여 UI를 만드는데 필요한 최소한의 것들만을 남기는 것이었다. 그렇게 되면 이해하기 쉽고, 사용하기 쉽고, 수정하기 쉬운, 뛰어나면서도 이타적인 구현물을 만들 수 있을 것이라고 판단했다.</p>
<p>이 글에서는 이러한 고통스러운 작업을 맛보는(<del>맛만 보는</del>) 실습을 기술적인 측면에서 진행해보려고 한다.</p>
<hr>
<h1 id="contents">Contents</h1>
<ul>
<li><a href="#%EA%B0%9C%EC%9A%94">개요</a></li>
<li><a href="#css">CSS</a></li>
<li><a href="#html">HTML</a></li>
<li><a href="#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%ED%99%94">컴포넌트화</a></li>
<li><a href="#non-component-ui">Non component UI</a></li>
<li><a href="#etc">ETC</a></li>
<li><a href="#%EB%94%94%EC%9E%90%EC%9D%B4%EB%84%88%EC%99%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EC%86%8C%EC%86%8C%ED%95%9C-%ED%98%91%EC%97%85">디자이너와 개발자의 소소한 협업</a></li>
<li><a href="#epilogue">Epilogue</a></li>
</ul>
<hr>
<h1 id="css">CSS</h1>
<p>css는 트릭이다. 명확한 인과관계가 있지만 모르는 사람이 보면 이해할 수 없다. 그래서 그러한 인과관계를 이해하지 못한 누군가가 작성한 구현물은 놀라울 정도로 지저분하다. 그러니 본내용을 설명하기에 앞서 먼저 css의 기초적인 부분을 이해하기 위해 몇가지 간단한 실습을 진행하고 넘어가려고 간다.</p>
<h2 id="정렬">정렬</h2>
<p>먼저 수평방향부터 생각해보자. 엘리먼트를 수평으로 정렬하는 방법은 여러가지가 있다.</p>
<ul>
<li>만약 width가 지정되어 있는(명시적이든, 암시적이든) 엘리먼트를 정렬하려면 <code>margin</code>을 <code>auto</code>으로 주어서 해결할 수 있다.</li>
<li>또는 엘리먼트(width가 지정되어 있는)의 내용물 및 하위 엘리먼트들을 정렬하고 싶다면 <code>text-align</code>을 사용할 수 있다. 이 때 하위 엘리먼트들은 인라인(인라인 블록도 포함)의 속성을 가지는 엘리먼트여야 한다.</li>
<li>위 경우로 해결되지 않는 경우(보통 인라인 엘리먼트) <code>float</code>를 사용할 수 있다. float를 사용하면 외부 블록의 영역을 무시하고 침범하므로 float를 사용한 엘리먼트 바로 다음에 <code>clear: both</code>를 적용한 엘리먼트를 첨가하거나, float를 사용한 엘리먼트를 감싸는 바깥 엘리먼트에 <code>overflow: auto</code>를 시도해볼 수 있다.</li>
</ul>
<!-- raw HTML omitted -->
<p>수직방향은 조금 더 트릭이다. 나는 오랫동안 <code>vertical-align</code>이 수직정렬이라고 생각했지만 내가 생각했던 수직정렬은 아니었다. 물론 table 디스플레이를 사용하면 그게 맞지만 그게 아니라면 <code>vertical-align</code>은 인라인 엘리먼트의 내부 컨텐츠(텍스트)의 정렬을 의미하는 것이었다. 하지만 많은 경우 블록 엘리먼트(height를 가지는)를 수직으로 정리할 일이 더 많기 때문에 난감했다. 이럴 때는 중앙정렬을 해야하는 엘리먼트의 상위 엘리먼트에다가 <code>line-height</code>를 자식 엘리먼트의 <code>height</code>보다 높게 주는 방법, 또는 <code>position: absolute</code>를 이용할 수도 있을 것이다. 하지만 그보다는 <code>flex</code>나 <code>table-cell</code>의 두가지 display 속성을 이용하는 것이 더 쉽고 부작용을 줄이는 방법이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;display: table;&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;display: table-cell; vertical-align: middle;&#34;</span>&gt;
    content here
  &lt;/<span style="color:#f92672">div</span>&gt;
  ...
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><p>하지만 위의 솔루션으로 해결되지 않는 UI가 종종 있는데, 예를 들면 엘리먼트가 동적으로 생기거나 사라지는 경우 또는 정렬해야 하는 엘리먼트들이 많아서 통제하기가 어려운 경우가 있을 것이다. 이 경우에는 <code>flex</code>를 사용하면 간편하다.</p>
<p>처음 flex를 사용했을 때에는 <code>display: table</code>과 비슷하다는 생각을 했었지만 table이 단순히 셀마다 비율을 지정해 정렬을 하는게 기본값이지만 flex는 엘리먼트들을 비율로 지정할 수도 있고, 그렇지 않아도 되어서 좋다.</p>
<p>flex를 사용했을 때 몇 안되는 단점은</p>
<ul>
<li>IE 브라우저가 이것을 불완전하게 지원하고(autoprefixer로 벤더접두어를 주어서 렌더링한다고 해도)</li>
<li>다른 속성들을 무시해버리거나 충돌이 나는 경우가 있다는 점이다.</li>
</ul>
<p>실례로 나는 최근 float-clearfix 조합으로 정렬을 하던 방식을 flex-justify-content 조합으로 수정한 적이 있는데, clearfix(clear 속성)가 flex와 충돌을 일으킬 것이라고는 생각을 안해서 디버깅하는 과정에서 애를 먹은 적이 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;display: flex; justify-content: space-between&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><p>그래서 만드려는 UI가 유연하지 않아도 되거나 <code>inline-block</code> 정도로 쉽게 해결되는 경우 flex를 사용하지 않는게 더 나은 것 같다. 정리하면 나는 정렬을 할 때 부작용 및 구현 난이도를 고려해서 다음의 순서대로(왼쪽 우선) 사용하는 편이다. <code>text-align -&gt; margin -&gt; flex -&gt; float -&gt; line-height</code></p>
<h2 id="relative-absolute-z-index">relative, absolute, z-index</h2>
<p>relative 속성이 지정된 엘리먼트와 아닌 것의 차이가 뭘까? 겉보기에는 다를 것이 없어보여서 absolute를 지정하기 위한 용도 외에는 없는 것으로 보이기도 한다. 무슨 말이냐면 relative 속성을 적용한 엘리먼트 내부에 absolute 엘리먼트를 사용하면, absolute 엘리먼트의 위치는 relative 엘리먼트의 좌측 상단 (0, 0)에 위치한다는 것이다. 그렇지만 그 외에 다른 이유가 있다. relative 속성을 이용하면 <code>top, left, right, bottom</code> 등의 절대 위치를 이동하는 속성을 적용할 수 있고, <code>z-index</code> 역시 relative, absolute가 지정되어 있지 않으면 해당 속성이 무시된다.</p>
<ul>
<li>z-index는 높을 수록 UI 우선순위가 높다. 영역이 겹칠 경우 z-index 값이 높은 것을 표현한다.</li>
<li>relative 속성은 내부 엘리먼트로 absolute를 쓰거나, 절대위치 이동(top, left 등)을 하거나, z-index를 사용해야 의미가 있다.</li>
<li>relative 속성은 절대 위치 이동을 하지 않은 경우 텍스트 상으로 먼저 렌더링 된 엘리먼트 다음에 만들어지는 반면, absolute는 (0, 0)에 표현된다.</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="flex">flex</h2>
<p>flex는 간결하고 유연한 UI를 만드는데 좋은 도구이다. 이걸 사용하면 수직-수평 정렬이 매우 쉽고, 좌우끝 정렬이나 아이템을 쌓는 방향(row, column)도 가능하고, 아이템의 기본넓이를 지정하되 영역이 충돌하면 비율을 지정할 수도 있다. 아래 예시는 flex로 가능한 것들 중 일부일 뿐이다.</p>
<!-- raw HTML omitted -->
<h2 id="overflow">overflow</h2>
<p>UI 작업을 하다보면 엘리먼트가 지정한 넓이와 높이를 넘어서는 경우가 종종 있다. 텍스트가 길거나, 이미지가 크거나, 엘리먼트가 가변적으로 늘어나거나, float를 사용했거나 하는 등등의 이유로 말이다. <code>overflow: scroll</code>을 적용하여 스크롤을 만들 수도 있겠지만 더 나은 UI를 위해서는 조금 더 고민해보아야 한다. 텍스트가 길어지면 <code>word-wrap: break-word</code>를 주어 다음줄로 넘어가게 할 것인가? 아니면 텍스트 엘리먼트 바깥 엘리먼트에 <code>overflow: hidden; text-overflow: ellipsis;</code>를 주어서 초과하는 부분에 대하여 <code>...</code>으로 그것을 대신할 것인가?</p>
<h2 id="hover-focus-active-disabled">hover, focus, active, disabled</h2>
<p>Pseudo class라고 알려진 것들 중 위의 4가지만 살펴보자.</p>
<ul>
<li>hover : 해당 UI 영역이 어디까지인지 표현. UI 버튼 같은 경우 마우스를 해당 영역에 가져다 두기만 해도 발생</li>
<li>focus : 해당 UI 영역이 선택되었음(활성화나 동작과 무관하게)을 표현. input 필드 같은 경우 해당 필드가 선택되었고 텍스트 입력이 가능하다는 것을 나타낼 수 있다. focus는 해당 UI를 tab 키로 이동하거나, 마우스를 누른 경우(떼지 않아도 상관없다, 그리고 드래그해서 해당영역 밖에서 떼도 포커스 상태 유지) 발생</li>
<li>active : 해당 UI 영역이 활성화되었음을 표현. 내비게이션 바에서 어떤 페이지가 활성화되었는지 표현할 수 있을 것이다. pseudo class 방식 외에도 명시적으로 <code>active</code> 클래스 등을 사용하기도 한다.</li>
<li>disabled : 해당 UI 영역에 기능이 비활성화되었음을 표현. active와 마찬가지로 명시적으로 <code>disabled</code> 클래스를 적용하기도 한다.</li>
</ul>
<h2 id="media-query">media query</h2>
<p>웹서비스들의 내비게이션 바를 보면 태블릿 사이즈(768px) 이상에서는 메뉴들이 나오지만 모바일(767px 이하)에서는 메뉴(≡) 아이콘 하나로 표현되는 경우를 본 적이 있을 것이다. 이런 것들은 css의 미디어 쿼리와 <code>display: hidden</code>의 조합으로 만들 수 있다. 이처럼 렌더링은 되었지만 숨겨놓다가 보여주기도 하고, 아니면 디스플레이 사이즈에 따라 <code>flex</code> 엘리먼트가 <code>inline-block</code> 엘리먼트로 바뀔 수도 있다. 더 자세한 정보는 다른 사이트에서 쉽게 찾아볼 수 있으니 생략하겠다.</p>
<h2 id="px-rem">px, rem</h2>
<p>rem을 쓰면 최상단 엘리먼트에서 설정한 폰트 크기를 기준으로 폰트 사이즈를 일괄적으로 바꿀 수 있으므로 유용하다. 절대적인 크기를 원하면 px로 주면 되고, 최상단 태그(html 태그)에서 지정한 폰트를 1rem으로 판단하고 하위 요소에 rem을 적용할 수도 있다.</p>
<!-- raw HTML omitted -->
<h1 id="html">HTML</h1>
<p>html은 짧게만 언급하려고 한다. div 태그 외에 보다 semantic한 이름을 사용할 수 있다는 것을 알 것이다. <code>header, nav, section, article, main, table, ul, li, hr</code> 등등 말이다. 이것들을 사용하는 것은 좋으나 해당 태그의 브라우저 지원여부를 알아본 뒤, 용도와 제약사항을 준수하여 사용해야 한다. 예를 들어, <code>nav</code> 태그는 내비게이션 스타일이면 전부 사용하는 것이 아니라 매인 내비게이션 바(주로 상단에 위치할 것이다)에 사용해야 한다. 그리고 <code>table</code>은 레이아웃을 잡는 용도가 아니라 명확히 테이블 형태의 데이터 표현을 하는 경우에 사용해야 한다. 또한 <code>ul</code>은 하위 태그로 <code>li</code> 만을(그것도 리스트로 표현해야 하는 내용물이 안에 들어가야 한다) 사용해야한다.</p>
<h1 id="컴포넌트화">컴포넌트화</h1>
<p>위에서 든 예시에는 의도적으로 class를 거의 사용하지 않고 inline style로 UI를 만들었다. 보다시피 굉장히 보기 어렵다는 것을 알 수 있다. 보기도 어렵지만 저렇게 하면 UI 요소를 컴포넌트로 만들 수가 없다. 따라서 이제부터는 컴포넌트화를 진행하여 간결하게 UI를 표현할 수 있도록 수정하려고 한다.</p>
<h2 id="파일구조">파일구조</h2>
<p>모든 클래스들이 파일 하나에 들어있으면 파일 안에 뭐가 있는지 그리고 그 안으로 가도 뭐가 뭔지 파악을 하기가 어렵다. 따라서 온톨로지 개념을 적용한다는 취지로 각 컴포넌트를 하나의 파일로 분리하고, 내부적으로는 주석으로 세부영역을 나누려고 한다. 여기서는 부트스트랩 등의 외부 라이브러리를 기반으로 만든다는 가정을 하므로, 구조와 내용물이 그것들과 비슷한 부분이 많을 것이다. 나의 경우에는 이러한 호환에 있어서 엄격한 BEM보다 가이드의 성격을 띄는 SMACSS적인 방법론을 따르는 것이 적절하다고 판단했다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">ui-component
├── partials
│   ├── _base.scss
│   ├── _common.scss
│   ├── _layout.scss
│   ├── _modules.scss
│   ├── _themes.scss
│   ├── _utils.scss
│   ├── _variables.scss
│   ├── modules
│   │   ├── _buttons.scss
│   │   ├── _chips.scss
│   │   ├── _dividers.scss
│   │   ├── _dropdowns.scss
│   │   ├── _forms.scss
│   │   ├── _glyphicons.scss
│   │   ├── _lists.scss
│   │   ├── _navbar.scss
│   │   ├── _page-headers.scss
│   │   ├── _panels.scss
│   │   └── _tables.scss
│   ├── themes
│   │   ├── _default.scss
│   │   └── _utils.scss
│   └── utils
│       ├── _extends.scss
│       ├── _functions.scss
│       └── _mixins.scss
└── ui-component.scss
</code></pre></div><p>위의 파일구조는 컴포넌트 작업의 일부분을 가정하여 만든 예시이다. 파일 내부 내용물은 생략하고 각 디렉토리만 설명하겠다.</p>
<h3 id="partials">partials</h3>
<p><code>partials</code>라는 네이밍은 흔한 방식인데, 그 기원은 <code>scss</code>가 Ruby 언어로 만들어진게 영향을 주었을 것이다. 루비에서 저렇게 많이 쓴다고 하니까. 다른 곳으로 로딩되어지는 파일은 <code>_</code> 접두어가 붙어있음을 알 수 있다.</p>
<h3 id="modules">modules</h3>
<p>부트스트랩의 구조와 흡사하게 각 UI 요소를 파일로 분리하였다. 이 디렉토리 안에 있는 파일 하나하나가 곧 하나의 UI 컴포넌트라고 생각할 수 있다. Google material design에서 나온 list나 chip같은 컴포넌트도 여기에 포함하였음을 알 수 있다.</p>
<h3 id="utils">utils</h3>
<p>scss를 사용하면 mixin 뿐만 아니라 extend, function을 사용할 수 있다. 요 3가지 개념을 다른 개발자들이 유틸이라고 명명한 것을 보고 괜찮다고 생각해서 차용했다. 믹스인은 가장 범용적으로 사용할 수 있는 기능인데, 속성이 가변적으로 변해야 하는 경우에 사용하면 적합하다. extend는 이와는 다르게 공통적으로 사용되는 고정된 속성들을 지정할 때 사용한다. 하지만 extend가 미디어쿼리(반응형이나 어댑티브)에서 적용이 안되므로 믹스인으로 대체해도 무방하다. function은 아직 내가 활용범위를 파악하지 못했지만, 입력받은 값을 특정 계산을 하여 원하는 값으로 바꾸어 출력(반환)하는 경우에 사용하고 있다. 예를 들어, px을 rem으로 바꾸는데 함수를 사용하면 적절할 것이다.</p>
<h3 id="themes">themes</h3>
<p>테마의 정의는 <strong>개요</strong>에서 설명했다. 사실 이 정의는 부트스트랩이 제공하는 테마기능과 유사하다. 즉, 여기서 테마란 사실 기술적으로는 가변적인 변수와 믹스인의 모음에 지나지 않는다. 배경색을 바꾸고, 폰트크기를 바꾸고, 엘리먼트의 사이즈를 바꾸는 것은 사실 scss의 변수값을 바꾸는 것이기 때문이다.</p>
<h3 id="스타일-성격에-따른-개념-정의-위치">스타일 성격에 따른 개념 정의 위치</h3>
<p>흔히 사용하는 <code>.</code>으로 시작하는 선택자들은 html에서 단독적으로 사용되는 형태이고 css에서 종속적으로 <code>@include</code>, <code>@extends</code>되지 않는 요소들이다. 또한 자식(자손)선택자로 다른 선택자들과 종속 관계가 있어야 하는 경우에도 가급적 한 파일을 벗어나지 않도록 해야한다. 하지만 라이브러리 차원에서의 종속성은 파일을 벗어나도 상관없다. 예를 들어, <code>non-ui-component</code>보다 <code>ui-component</code>가 상위 라이브러리라면 <code>ui-component</code>에서 정의한 선택자들과 종속관계를 맺어도 된다. 물론, 그 경우 아래의 import 의존성을 가지는 것을 전제로 한다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css"><span style="color:#f92672">//</span> <span style="color:#f92672">UI</span> <span style="color:#f92672">Component</span>
@<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;ui-component&#39;</span>;
<span style="color:#f92672">//</span> <span style="color:#f92672">Non</span> <span style="color:#f92672">UI</span> <span style="color:#f92672">Component</span>
@<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;non-ui-component&#39;</span>;
</code></pre></div><h2 id="로딩구조">로딩구조</h2>
<p>위의 파일구조에서 각 파일들은 개념에 따라 묶어서 로딩이 되고, 그걸 더 큰 개념의 일부로 판단하여 로딩이 되는 구조이다. 예를 들어, <code>utils</code>라는 디렉토리에 있는 파일들은 그 디렉토리 바깥에 있는 <code>_utils.scss</code>에서 로딩하고, 이것은 <code>partials</code> 바깥에 있는 <code>ui-component.scss</code>에서 로딩할 수 있다. 이렇게 하면, 개념이 늘어나거나 줄어들 때에 그저 디렉토리에 파일을 하나 추가하거나 삭제하면 되기 때문에 유용하다. 예를 들어, 테마의 개수가 수정이 되면 <code>_themes.scss</code>에서 해당 파일의 <code>@import</code>하는 부분을 &lsquo;추가/삭제&rsquo;하면 된다 된다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css"><span style="color:#f92672">//</span> <span style="color:#f92672">Theme</span>
@<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;./partials/_themes&#39;</span>;
<span style="color:#f92672">//</span> <span style="color:#f92672">Variables</span>
@<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;./partials/_variables&#39;</span>;
<span style="color:#f92672">//</span> <span style="color:#f92672">Utils</span>
@<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;./partials/_utils&#39;</span>;
<span style="color:#f92672">//</span> <span style="color:#f92672">Base</span> <span style="color:#f92672">&amp;</span> <span style="color:#f92672">Common</span> <span style="color:#f92672">elements</span>
@<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;./partials/_base&#39;</span>;
@<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;./partials/_common&#39;</span>;
<span style="color:#f92672">//</span> <span style="color:#f92672">Layout</span>
@<span style="color:#66d9ef">import</span>  <span style="color:#e6db74">&#39;./partials/_layout&#39;</span>;
<span style="color:#f92672">//</span> <span style="color:#f92672">Modules</span>
@<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;./partials/_modules&#39;</span>;
</code></pre></div><p>이 때 로딩순서를 주의하자. 예를 들어, 여기서 테마 로딩은 유틸보다 앞서지만, 테마를 위한 유틸은 따로 있는 것이다. 이것이 의미하는 것은 유틸은 테마에서 지정된 값을 사용할 수 있다는 것이다 (종속성이 있을 수 있다는 의미).</p>
<h2 id="구조와-표면">구조와 표면</h2>
<p>OOCSS에서 나오는 말이 있다. &lsquo;구조structure와 표면skin을 분리하자&rsquo;. 비슷한 개념으로 나는 UI 요소를 크게 item과 item-box의 2가지로 나타낸다. 예를 들어, text이면 text, text-box로 두고, 아래처럼 사용할 수 있을 것이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">text</span> {
  <span style="color:#66d9ef">font-size</span>: <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#66d9ef">text</span><span style="color:#f92672">-</span><span style="color:#66d9ef">size</span>;
  <span style="color:#66d9ef">color</span>: <span style="color:#960050;background-color:#1e0010">$</span>btn-color;
}

.<span style="color:#a6e22e">text-box</span> {
  <span style="color:#66d9ef">padding</span>: <span style="color:#ae81ff">10</span><span style="color:#66d9ef">px</span>;
  <span style="color:#66d9ef">word-wrap</span>: <span style="color:#66d9ef">break-word</span>;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text-box&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text&#34;</span>&gt;
    Some text here.
  &lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><h2 id="네이밍">네이밍</h2>
<p>선택자 이름은 명확하고 중복되지 않아야 한다.</p>
<ul>
<li>예를 들어, 여러 라이브러리들을 사용하고 있다면 어떤 라이브러리에서 정의된 선택자인지, 또 같은 이름을 쓰는 선택자들이 없도록 해야하므로, 특정 이름을 접두어로 강제할 수도 있다.
<ul>
<li>font-awesome같은 라이브러리는 그런 이유로 <code>fa-</code>라는 접두어를 기본으로 두는 것 같다.</li>
</ul>
</li>
<li>라이브러리 간 구분을 할 수 있다고 하면, 그 다음은 모듈(컴포넌트) 별로 선택자들을 구분할 수 있어야 한다. 이 때에는 간단히 모듈명을 추가하면 된다.
<ul>
<li><code>chip-text-box</code>, <code>card-text-box</code> 이런 식으로.</li>
</ul>
</li>
<li>모듈 간 구분이 가능하면 그 다음은 모듈 내부에서 UI 성격에 따라 구분할 수 있어야 한다.
<ul>
<li>Theme
<ul>
<li>같은 기종의 스마트폰이라도 색상은 서로 다를 수 있듯이 같은 컴포넌트라도 서로 다른 구조와 표면을 가질 수 있다(다른 의미지만 일종의 테마).
<ul>
<li><code>card-heading-salt</code>, <code>card-content-salt</code></li>
<li><code>card-heading-pepper</code>, <code>card-content-pepper</code></li>
</ul>
</li>
</ul>
</li>
<li>Sizing
<ul>
<li>사이즈 별로 구분도 해야겠지만 그 방식도 고정(width, height)이냐, 가변이냐(padding, margin)에 따라 다르다.
<ul>
<li><code>card-md</code>, <code>card-md-fixed</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>이상을 적용하면 요런 식으로 만들 수 있을 것이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-heading card-heading-salt&#34;</span>&gt;
   &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-text-box&#34;</span>&gt;
     &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-text card-text-md&#34;</span>&gt;
     &lt;/<span style="color:#f92672">div</span>&gt;
   &lt;/<span style="color:#f92672">div</span>&gt;
  &lt;/<span style="color:#f92672">div</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-body card-body-salt&#34;</span>&gt;
    ...
  &lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-heading card-heading-pepper&#34;</span>&gt;
   &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-text-box&#34;</span>&gt;
     &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-text card-text-md&#34;</span>&gt;
     &lt;/<span style="color:#f92672">div</span>&gt;
   &lt;/<span style="color:#f92672">div</span>&gt;
  &lt;/<span style="color:#f92672">div</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card-body card-body-pepper&#34;</span>&gt;
    ...
  &lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><p>이렇게 하면 만사형통일 것 같지만 사실 여기서부터가 시작이다. <code>card-text</code>는 <code>card-heading</code>에만 쓰이는 특수한 것인가? 아니면 <code>card</code> 모듈 내부라면 어디서나 쓰일 수 있는 것일까? 컴포넌트 테마에 따라서 이 텍스트 스타일을 따로 정의해야 할까, 아니면 자식 선택자<code>&gt;</code>를 이용하여 각 컴포넌트 테마에 맞게 수정해야 하는 것일까? 각 컴포넌트 테마에 하위 요소를 종속시켜 버리면, 코드 양이 줄지만 선택자 간에 종속성이 생기므로 좋지 않고, 반대로 각 컴포넌트 테마에 따라 모든 하위 UI 요소를 위한 선택자를 따로 정의하면 오해의 소지가 없고 선택자 간에 의존성 구조를 없앨 수는 있지만 코드 양이 늘고, 선택자 이름도 너무 길어지는 것이 아닌가, 하는 생각도 든다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">card-heading-pepper</span> {
  <span style="color:#960050;background-color:#1e0010">...</span>
  <span style="color:#960050;background-color:#1e0010">&gt;</span> <span style="color:#960050;background-color:#1e0010">.card-text</span> <span style="color:#960050;background-color:#1e0010">{</span>
    <span style="color:#66d9ef">font-size</span>: <span style="color:#ae81ff">20</span><span style="color:#66d9ef">px</span>;
  }
<span style="color:#960050;background-color:#1e0010">}</span>
</code></pre></div><p>위는 종속, 아래는 독립 형태이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">card-heading-pepper</span> {
<span style="color:#960050;background-color:#1e0010">...</span>
}

.<span style="color:#a6e22e">card-heading-text-pepper</span> {
  <span style="color:#66d9ef">font-size</span>: <span style="color:#ae81ff">20</span><span style="color:#66d9ef">px</span>;
}
</code></pre></div><p>네이밍이 명확한 것은 물론 좋지만 생략해도 의미가 손실되지 않는다면 하는게 좋은 것 같다. 예를 들어, <code>card-body-item-text-box</code>라고 하자. 만약, <code>card-body-text-box</code>라고 하더라도 그것이 item이라는 개념을 지칭하는 것이 분명하다면 그렇게 하는 것이다.</p>
<p>네이밍에 답은 없으므로 협업하는 다수의 동료가 납득 가능하게 만들어야 겠지만, 그러면서도 가급적 유니버설하게 만들어야 작업물의 쓰임새와 수명을 늘릴 수 있을 것 같다.</p>
<h2 id="변수">변수</h2>
<p>프로그래밍 언어에서는 변수나 함수의 반환값이 아닌 숫자가 그대로 들어가 있는 경우를 하드코딩의 한 종류로 본다. css에서도 변수를 만들면 명확한 의미를 줄 수 있다는 장점이 있다. 하지만 css는 숫자값이 상당히 많아서 모든 값을 변수로 만들어버리면 관리하기가 어려워진다. 그래서 변수를 만들어서 적용할 때에는 변수처리가 꼭 필요한 부분부터 적용하여 관리의 손길이 닿는 범위에서(통제가 가능한) 확장해야 할 것 같다. 변수 네이밍은 위의 선택자 네이밍과 비슷하지만 선택자보다는 그 범위나 용도가 한정적이어서 축약형을 사용하기가 좋다. 예를 들어, 버튼의 배경색은 <code>$button-background-color</code> 대신에 <code>$btn-bg</code> 정도로 나타낼 수가 있다.</p>
<h2 id="공간-주기">공간 주기</h2>
<p>방금 전 <code>item-box</code>로 사이징을 한다고 했다. 하지만 UI 레이아웃을 구성할 때, 딱히 어떤 모듈의 box에 속한다고 보기 어려운 여백이 필요할 때가 참 많다. 그럴 때에는 오로지 공간을 주기위한 선택자를 만들어 집어넣는 것도 방법인 것 같다. 이렇게 하면 <code>item-box</code>의 의미를 지킬 수 있으면서도 UI 레이아웃을 유연하게 바꿀 수 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">@<span style="color:#66d9ef">for</span> <span style="color:#f92672">$</span><span style="color:#f92672">i</span> <span style="color:#f92672">from</span> <span style="color:#f92672">1</span> <span style="color:#f92672">through</span> <span style="color:#f92672">10</span> {
  .<span style="color:#a6e22e">margin-v-</span><span style="color:#960050;background-color:#1e0010">#</span>{<span style="color:#960050;background-color:#1e0010">$i</span>} {
    <span style="color:#66d9ef">display</span>: <span style="color:#66d9ef">inline</span><span style="color:#f92672">-</span><span style="color:#66d9ef">block</span>;
    <span style="color:#66d9ef">margin-top</span>: <span style="color:#960050;background-color:#1e0010">$</span>index <span style="color:#f92672">+</span> px;
  }
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;item-a&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;margin-v-5&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;item-b&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><h2 id="인라인-스타일">인라인 스타일</h2>
<p>인라인 스타일만 필요할 때도 있다. 선택자 네이밍이 아직 정해지지 않았거나, 특정 페이지에서만 다르게 적용해야 하는 컴포넌트 UI가 있을 때 등등 말이다. 그럴 때에는 인라인스타일 대신 인라인 스타일 클래스를 만들어서 사용하는 것도 방법이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">
.<span style="color:#a6e22e">text-align-right</span> {
  <span style="color:#66d9ef">text-align</span>: <span style="color:#66d9ef">right</span>;
}

.<span style="color:#a6e22e">item-something-box</span> {
  <span style="color:#960050;background-color:#1e0010">...</span>
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;item-something-box text-align-right&#34;</span>&gt;
  ...
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><h2 id="item-group과-pseudo-class">Item group과 pseudo class</h2>
<p><code>item-box</code>와는 또 다르게 item들을 여러개 묶어서 표현해야할 때가 있다. 예를 들어, 토글버튼은 2개의 버튼이 묶인 형태인데 이럴 경우 <code>btn-group</code>을 만들어 사용할 수 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">btn-group</span> {
  <span style="color:#960050;background-color:#1e0010">.btn</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#960050;background-color:#1e0010">.btn,</span>
  <span style="color:#960050;background-color:#1e0010">.btn</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#960050;background-color:#1e0010">.btn-group,</span>
  <span style="color:#960050;background-color:#1e0010">.btn-group</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#960050;background-color:#1e0010">.btn,</span>
  <span style="color:#960050;background-color:#1e0010">.btn-group</span> <span style="color:#960050;background-color:#1e0010">+</span> <span style="color:#960050;background-color:#1e0010">.btn-group</span> <span style="color:#960050;background-color:#1e0010">{</span>
    <span style="color:#66d9ef">margin-left</span>: <span style="color:#ae81ff">-1</span><span style="color:#66d9ef">px</span>;
  }
<span style="color:#960050;background-color:#1e0010">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>해석하면 오른쪽에 있는 버튼은 왼쪽에 1px만큼 이동해서 겹쳐진다는 뜻이다.</p>
<p>이와 비슷하게 ul 태그에 붙이는 <code>list-group</code> 선택 같은 경우 li 태그에 대하여 마지막 li 태그를 제외하고 border-bottom을 주고싶을 수가 있다. 그 경우 pseudo class를 사용하여 아래와 같이 줄 수가 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">list-group</span> {
  <span style="color:#960050;background-color:#1e0010">.list-item</span> <span style="color:#960050;background-color:#1e0010">{</span>
    <span style="color:#960050;background-color:#1e0010">&amp;:not(:last-child)</span> <span style="color:#960050;background-color:#1e0010">{</span>
      <span style="color:#66d9ef">border-bottom</span>: <span style="color:#ae81ff">1</span><span style="color:#66d9ef">px</span> <span style="color:#66d9ef">solid</span> <span style="color:#66d9ef">black</span>;
    }
  <span style="color:#960050;background-color:#1e0010">}</span>
<span style="color:#960050;background-color:#1e0010">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">ul</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;list-group&#34;</span>&gt;
  &lt;<span style="color:#f92672">li</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;list-item&#34;</span>&gt;no border-bottom&lt;/<span style="color:#f92672">li</span>&gt;
  &lt;<span style="color:#f92672">li</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;list-item&#34;</span>&gt;yes border-bottom&lt;/<span style="color:#f92672">li</span>&gt;
  &lt;<span style="color:#f92672">li</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;list-item&#34;</span>&gt;no border-bottom&lt;/<span style="color:#f92672">li</span>&gt;
&lt;/<span style="color:#f92672">ul</span>&gt;
</code></pre></div><p>참고로 pseudo class는 concatenate이 가능하다. <code>&amp;:not(:first-child):not(:last-child)</code>와 같이 첫번째와 마지막에 위치한 선택자가 아닌 조건을 만들어 필터링할 수 있다.</p>
<h2 id="built-in-function">Built-in function</h2>
<p><code>darken</code>, <code>lighten</code>과 같은 내장된 함수를 사용하면 쉽게 UI 요소의 느낌을 바꿀 수 있다. 부트스트랩이 버튼 UI에 대해 이미 사용하고 있는 방식인데, 예를 들면 <code>btn:hover</code>일 때에는 <code>darken</code>을 10%정도 줘서 그만큼 더 어둡게 만드는 식이다. 이게 번거로운 반복 작업을 일괄적으로 하게 만드는 장점이 있는데, 테마에 따라 UI의 느낌을 다르게 줄 때에도 시간을 많이 아껴줄 것 같다.</p>
<h1 id="non-component-ui">Non component UI</h1>
<p>UI 컴포넌트 만으로 UI가 구현된다면 얼마나 좋을까? 하지만 현실은 그렇지 않다. 컴포넌트에 포함시키기 어려운 외부 라이브러리들과 특정 뷰와 특정 도메인에 특수한 UI가 많기 때문이다. 예를 들어, 아이콘 스타일의 폰트를 표현하기 위해서 &lsquo;font-awesome&rsquo; 라이브러리를 사용한다고 하자. 그런데 기존에 설정된 속성을 바꾸고 싶은 경우 어디에 이것을 정의하고 덮어씌워야 하는 것일까? 적어도 이게 컴포넌트는 아닐 것이다. 다른 예로, UI 상에 사용하는 텍스트 스타일을 지정하기 위하여 &lsquo;font-sm&rsquo;, &lsquo;font-md&rsquo;, &lsquo;font-lg&rsquo;의 3가지를 만들어서 사용하고 있다고 하자. 그런데 &lsquo;pepper&rsquo;라는 도메인을 나타내는 경우에만 컴포넌트로 정의하지 않은 폰트스타일을 사용해야 하는 것이다. 이것 역시 컴포넌트가 아니다.</p>
<p>나의 경우에는 고민 끝에 컴포넌트에 포함될 수 없는 스타일을 모으기 위한 디렉토리를 따로 하나 만들었다. 이 디렉토리는 UI 컴포넌트에서 이미 정의한 스타일을 사용할 수는 있지만 그 역으로는 사용할 수 없다(하고 싶어도 로딩 의존성 때문에 못한다).</p>
<p>도메인에 특수한 것을 뷰에 특수한 것의 일부로 보았을 때 파일 구조를 아래처럼 생각해볼 수 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">non-ui-component
├── partials
│   ├── _common.scss
│   ├── _layout.scss
│   ├── _lib.scss
│   ├── _themes.scss
│   ├── _utils.scss
│   ├── _variables.scss
│   ├── _views.scss
│   ├── themes
│   │   ├── _default.scss
│   │   └── _utils.scss
│   ├── utils
│   │   ├── _extends.scss
│   │   ├── _mixins.scss
│   │   ├── extends
│   │   │   ├── _common.scss
│   │   │   ├── _lib.scss
│   │   │   └── _views.scss
│   │   └── mixins
│   │       ├── _common.scss
│   │       ├── _lib.scss
│   │       └── _views.scss
│   └── views
│       ├── _index.scss
│       ├── _salt.scss
│       └── _pepper.scss
└── non-ui-component.scss
</code></pre></div><p>이미 위에서 설명한 <code>ui-component</code> 디렉토리의 구조와 흡사하므로 중복되는 것은 생략하면, 다른 것은 파일 구조가 library와 view로 분리되어 있다는 것 뿐이다. 이렇게 분리한 이유는 이렇게 하지 않으면 파일 안에 존재하는 수많은 스타일들 각각이 특정 뷰에만 사용되는 것인지, 아니면 라이브러리에 의존성을 가지는 것을 덮어 씌운 것이거나 새로 만든 것인지 알 수가 없기 때문이다. 그래도 컴포넌트가 아닌 UI가 가지는 장점이 있는데, 바로 컴포넌트라는 견고한 구조에서 벗어나 다소 유연하게 뷰의 구조를 스타일링할 수 있다는 점이다.</p>
<h1 id="etc">ETC</h1>
<h2 id="작업-방법">작업 방법</h2>
<p>UI는 언제든 바뀔 수 있는 부분이다. 따라서 어떻게 바꿀지 가늠을 해봐야 하는데 나의 경우에는 그 프로세스를 대략 아래 순서로 진행하는 것 같다.</p>
<ol>
<li>빠르게 전체를 훑어본다</li>
<li>기존 구조를 유지한 채 개선하는게 좋다면 그렇게 한다</li>
<li>새 구조를 만드는게 나을 것이라고 판단하면, 내용물(텍스트, 이미지)만 남긴채 모든 구조(<code>box</code>, inline style)를 해체한다.</li>
</ol>
<ul>
<li>div가 4중 5중으로 중첩되어 있고, 각각이 어떻게 영향을 주는지 파악이 어려운 경우 등</li>
</ul>
<ol start="4">
<li>내용물로부터 새 구조를 설계한다.</li>
</ol>
<p>그리고 컴포넌트를 만들 때에는 아래와 같은 순서로 작업한다.</p>
<ol>
<li>컴포넌트 선택자 이름을 정의한다.</li>
</ol>
<ul>
<li><code>chip</code></li>
</ul>
<ol start="2">
<li>가능한 컴포넌트 하위 선택자 요소를 정의한다.</li>
</ol>
<ul>
<li><code>chip-image-box</code>, <code>chip-text-box</code>, &hellip;</li>
</ul>
<ol start="3">
<li>내가 별도의 학습없이 작성할 수 있는 수준에서 필요한 속성들을 각 선택자에 부여한다.</li>
<li>다른 컴포넌트 라이브러리들(예: 부트스트랩)에서 비슷한 컴포넌트가 정의된 부분을 참고하여 디테일을 완성한다. 이 때, 꼭 필요한 속성만 참고해서 가져오고, 부작용 방지 및 간결성 유지를 위하여 작성자가 제대로 이해하지 못하는 속성은 가져오지 않는다.</li>
</ol>
<h2 id="언어학">언어학</h2>
<p>나는 뜻밖에도 html, css에서 언어학적인 구조를 느낄 수 있었다. 그 중에서도 흔히 기호학(semiotics)이라고 일컬어지는 &lsquo;의미론 - 통사론 - 화용론&rsquo;의 세가지 요소 말이다.</p>
<ul>
<li>의미론 : CSS의 각 선택자가 지칭하는 각각의 사물(UI 요소)들이 지칭하는 대상을 설계</li>
<li>통사론 : CSS의 각 성분(스타일)을 HTML의 구조에 적용하고 의미를 해석</li>
<li>화용론 : 설계한 UI를 &lsquo;사람 - 컴퓨터 - 사람&rsquo; 사이에서 상호작용하는 것</li>
</ul>
<p>또한 사람과 컴퓨터의 관계적인 측면도 생각해볼 수 있었다.</p>
<ol>
<li>사람 - 컴퓨터 - 사람</li>
<li>컴퓨터 - 컴퓨터</li>
</ol>
<h2 id="html-계층hierarchy의-올바른-추상화">html 계층(hierarchy)의 올바른 추상화</h2>
<p>올바른 계층 구조란 어떠해야 할까? 만약, 동일 계층에 여러개의 아이템이 존재할 경우 각 아이템이 그 계층에서 동일한 계층을 차지하는지 판단해보아야 한다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;theater&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;movie-room-box&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ticket-box&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;toilet-box&#34;</span>&gt;
    &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;toilet-for-man&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
    &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;toilet-for-women&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
  &lt;/<span style="color:#f92672">div</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;food-court&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><p>위의 html 계층 구조를 추상화하면 <code>[[M], [T], [[M], [W]], [F]]</code>와 같이 표현할 수 있다. html의 각 계층에 존재하는 아이템들을 올바른 추상화 수준으로 설계한다면 구조적으로 더욱 안전한(수정 및 개선에 용이한) 작업물을 만들 수 있을 것이다. 그리고 이런 뼈대가 튼튼해야만 &lsquo;UI 컴포넌트와 테마&rsquo;같은 수준의 작업을 제대로 진행할 수 있다.</p>
<h2 id="가변-ui-레이아웃을-지키는-제약">가변 UI 레이아웃을 지키는 제약</h2>
<p>작업자가 놓치기 쉬운 디테일 중 하나는 가변 UI 레이아웃에서의 제약일 것이다. 작업자가 UI를 고정된 형태(width, height의 고정)로만 설계해도 곤란하지만, 그렇다고 가변적인 형태로(margin, padding)만 만들어도 아쉬움이 뒤따른다. 왜냐하면 가변적인 UI는 내용물이 너무 작거나 클 때에는 예상하던 레이아웃을 깨버리기 때문이다. 이럴 때에는 단순하게 <code>min-width</code>, <code>max-height</code>처럼 몇가지 예외상황에 대한 처리만 해두면 UI 레이아웃을 지킬 수가 있다.</p>
<h2 id="파일-내-계층-정렬">파일 내 계층 정렬</h2>
<p>scss 파일 하나에는 여러개의 선택자들을 정의할 수 있다. 문제는 파일 내에 선택자들이 많아지면, 관리하기가 어려울 수 있다는 점이다. 재사용을 고려하여 설계한 선택자들이 단지 정의되어있는지 몰랐다는 이유로 반복 재정의가 된다면 안타까운 일이다. 따라서 선택자들을 정렬하는 방법이 필요하다. 하나의 방법을 제시한다면 &lsquo;계층 깊이대로 오름차순으로 정렬&rsquo;하는 것이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css">.<span style="color:#a6e22e">component-group</span>
.<span style="color:#a6e22e">component</span>
.<span style="color:#a6e22e">component-item-group</span>
.<span style="color:#a6e22e">component-item-group-pepper</span>
.<span style="color:#a6e22e">component-item-group-salt</span>
.<span style="color:#a6e22e">component-item-box</span>
.<span style="color:#a6e22e">component-item-box-pepper</span>
.<span style="color:#a6e22e">component-item-box-salt</span>
.<span style="color:#a6e22e">component-item</span>
.<span style="color:#a6e22e">component-item-pepper</span>
.<span style="color:#a6e22e">component-item-salt</span>
.<span style="color:#a6e22e">component-item-link</span>
.<span style="color:#a6e22e">component-image-box</span>
.<span style="color:#a6e22e">component-text-box</span>
.<span style="color:#a6e22e">component-image</span>
.<span style="color:#a6e22e">component-image-pepper</span>
.<span style="color:#a6e22e">component-image-salt</span>
.<span style="color:#a6e22e">component-text</span>
.<span style="color:#a6e22e">component-text-pepper</span>
.<span style="color:#a6e22e">component-text-salt</span>
</code></pre></div><p>위처럼 어떤 컴포넌트 이름을 &lsquo;component&rsquo;라고 가정하고 다음과 같은 순서대로 정의하였다.</p>
<ol>
<li>그것을 위한 그룹이 있는가? 그렇다면 이게 가장 위에서 정의</li>
<li>그 다음이 컴포넌트 자체</li>
<li>컴포넌트 내부를 차지하는 각 아이템들을 묶는 그룹(group)</li>
<li>아이템 박스</li>
<li>아이템</li>
<li>아이템 내부를 차지하는 이미지, 텍스트 등 직접적인 컨텐츠 영역</li>
</ol>
<p>이 경우 html은 아래처럼 만들어질 수 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-group&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component&#34;</span>&gt;
    &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-item-group component-item-group-pepper&#34;</span>&gt;
      &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-item component-item-pepper&#34;</span>&gt;
        &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-image-box&#34;</span>&gt;
          &lt;<span style="color:#f92672">img</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-image component-image-pepper&#34;</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>&gt;
        &lt;/<span style="color:#f92672">div</span>&gt;
        &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-text-box&#34;</span>&gt;
          &lt;<span style="color:#f92672">span</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-text component-text-pepper&#34;</span>&gt;
            TEXT HERE
          &lt;/<span style="color:#f92672">span</span>&gt;
        &lt;/<span style="color:#f92672">div</span>&gt;
      &lt;/<span style="color:#f92672">div</span>&gt;
    &lt;/<span style="color:#f92672">div</span>&gt;
  &lt;/<span style="color:#f92672">div</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component&#34;</span>&gt;
    &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-item-group component-item-group-salt&#34;</span>&gt;
      &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-item component-item-salt&#34;</span>&gt;
        &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-image-box&#34;</span>&gt;
          &lt;<span style="color:#f92672">img</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-image component-image-salt&#34;</span>&gt;
        &lt;/<span style="color:#f92672">div</span>&gt;
        &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-text-box&#34;</span>&gt;
          &lt;<span style="color:#f92672">span</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-text component-text-salt&#34;</span>&gt;
            TEXT HERE
          &lt;/<span style="color:#f92672">span</span>&gt;
        &lt;/<span style="color:#f92672">div</span>&gt;
      &lt;/<span style="color:#f92672">div</span>&gt;
    &lt;/<span style="color:#f92672">div</span>&gt;
  &lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><h2 id="style-lint-and-documentation">Style lint and Documentation</h2>
<p>프로젝트 설계 초반에 코드 스타일 가이드를 강제하지 않으면, 코드는 점점 무질서해진다. 이것은 &lsquo;scss&rsquo;에도 통하는 말일 것이다. 예를 들어, <code>sasslint</code> 같은 것을 도입하면 스타일 디렉토리 루트에 <code>.sass-lint.yaml</code>을 만들어 아래와 같은 설정을 해볼 수 있다.</p>
<pre><code>rules:
  property-sort-order:
    - 0
  class-name-format:
    - 0
  no-important:
    - 0
  no-empty-rulesets:
    - 1
  clean-import-paths:
    - 1
  single-line-per-selector:
    - 1
  nesting-depth:
    - 1
    - max-depth: 3
  leading-zero:
    - 0
  ...
</code></pre><p>선택자 네이밍을 잘했더라도 문서화는 필요하다. 가장 간단한 문서화의 형태는 주석으로, 아래와 같이 섹션을 나누거나 선택자에 설정하는 경우가 있을 것이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-css" data-lang="css"><span style="color:#f92672">/////////////////////////////////////////////////////////////</span>
<span style="color:#f92672">//</span>  <span style="color:#f92672">Component</span> <span style="color:#f92672">Group</span>

<span style="color:#f92672">///</span> <span style="color:#f92672">Main</span> <span style="color:#f92672">component</span> <span style="color:#f92672">group</span>
.<span style="color:#a6e22e">component-group</span> {}

<span style="color:#f92672">///</span> <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">Pepper</span><span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#f92672">style</span> <span style="color:#f92672">for</span> <span style="color:#f92672">main</span> <span style="color:#f92672">component</span> <span style="color:#f92672">group</span>
<span style="color:#f92672">///</span> @<span style="color:#66d9ef">todo</span> <span style="color:#f92672">-</span> <span style="color:#f92672">Refactor</span> <span style="color:#f92672">it</span>
<span style="color:#f92672">///</span> @<span style="color:#66d9ef">example</span>
<span style="color:#f92672">///</span>   <span style="color:#f92672">-</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">div</span> <span style="color:#f92672">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;component-group-pepper&#34;</span><span style="color:#f92672">&gt;&lt;/</span><span style="color:#f92672">div</span><span style="color:#f92672">&gt;</span>
.<span style="color:#a6e22e">component-group-pepper</span> {}
.<span style="color:#a6e22e">component-group-salt</span> {}

<span style="color:#f92672">/////////////////////////////////////////////////////////////</span>
<span style="color:#f92672">//</span>  <span style="color:#f92672">Component</span>

.<span style="color:#a6e22e">component-group</span> {}
.<span style="color:#a6e22e">component-pepper</span> {}
.<span style="color:#a6e22e">component-salt</span> {}
</code></pre></div><p>선택자에 적용한 주석의 slash가 3개인 것은 <a href="http://sassdoc.com/">sassdoc</a>을 위해서이다. Sassdoc을 이용하면 작성한 주석들을 토대로 보기 좋은 정적 UI를 만들어 주므로 유용하다.</p>
<h2 id="숙제">숙제</h2>
<p>사소하지만 생각해보아야 할 이슈들 가운데 몇가지만 숙제 형식으로 남겨둔다. 프로젝트의 상황에 따라 해결책은 각기 다를 것이다.</p>
<ul>
<li>
<p>UI가 UX와 상충될 경우 어떻게 해야할까? 우선순위에 대한 명확한 기준이 각 상황마다 있는가? 리소스, 합리성, 다수결의 원리, 권위자의 의견 등을 어떻게 배합해야 번복을 줄이고 더 견고한 스타일 구조를 만들 수 있을까?</p>
</li>
<li>
<p>컴포넌트가 아닌 요소들, 예를 들어 인라인 스타일들을 대체하는 선택자들은 어느 파일에 위치해야 할까?</p>
</li>
<li>
<p>변수를 정의할 때, 이것이 테마 요소의 일부가 아닌 경우 테마 파일에 정의해야 할까? 만약, 그렇지 않다면 어떻게 해결할 것인가? 따로 파일을 만들 것인가?</p>
</li>
<li>
<p>보통 어떤 아이템의 영역을 표시하거나 구분하거나 분리할 때 <code>border-bottom</code>을 사용한다. 하지만 이러한 분리선(divider)은 아이템의 넓이(width)에 종속되어 디테일한 UI를 만들지 못하게 만든다. 이것을 어떻게 해결할 것인가? 아이템과 분리할 수 있도록 분리선을 따로 만들 것인가? 아이템 내부에 박스를 두고 분리선을 줄 것인가?</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;item&#34;</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;

&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;item&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;box&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;divider&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><h1 id="디자이너와-개발자의-소소한-협업">디자이너와 개발자의 소소한 협업</h1>
<p>실제 웹서비스는 html, css로만 동작하지는 않는다. 자바스크립트 언어가 html, css와 뒤죽박죽 얽혀서 움직이기 때문에 디자이너가 실제 웹서비스에 변화를 주면서 작업을 하기는 쉽지가 않다. 이 경우, 비대한 웹서비스에서 디자인적 요소만 따로 떼어내어 디자인 작업 전용 레포지토리를 따로 만드는 방법을 시도해볼 수 있다. 작게는 정적파일(css, image, font)만 복사해올 수도 있고, 조금 더 나아가서 여러 scss 파일로 분리된 스타일을 자동 컴파일하게 만들어주고 가볍게 서버를 동작할 수 있도록 만들 수도 있을 것이다. 동적인 작업까지는 어려워도 정적인 뷰를 만들어볼 수는 있으니 조금만 시간을 들여 이런 작업을 같이 진행하면 개발자와 디자이너 간 협업에 있어서 어느 한쪽이 끝나야만 진행이 되는 상황을 벗어나서 각자가 역할을 분담할 수가 있다. 또한 작성한 작업물(css)을 어떻게 사용해야 하는지 UI 스타일 가이드를 제작하는 것도 디자인 전용의 별도의 레포지토리를 만들어두면 작업하기 수월하다.</p>
<h1 id="epilogue">Epilogue</h1>
<p>내가 작업하는 내용을 세세하게 기록할 수는 없어서 아쉽지만 그래도 이정도를 기록해둘 수 있어서 다행이다. 처음 css를 실습해볼 때에는 아주 지저분하고 논리적으로 해석이 불가능한 것처럼 느껴졌지만 나중에서야 css의 트릭만 익히면 그 안에 나름의 논리가 있음을 알게되었다. 그 다음부터는 점점 더 높은 퀄리티의 결과물이 나왔고 디자이너와 개발자 모두 보람을 느끼게 되었던 것 같다. 나는 많은 경우 <strong>UX, UI, Tech</strong>의 우선순위대로 제품이 제작되었으면 좋겠다고 생각해왔다. 기술에 맞춰서 UX와 UI를 만들면 성능은 좋을지 몰라도 정작 사용자가 쓰기에는 불편한 무엇이 나오지만, UX와 UI에 맞춰서 기술을 최적화하면 사용자를 위한 제품이 나온다고 생각을 하기 때문이다. 그러던 내가 최근 우연한 계기로 UI와 직접적으로 연관된 일을 하게되었다. 아쉽게도 한 번에 모든게 달라질 수는 없었지만, 내가 제품을 위하여 필요하다고 생각하는 변화를 실제로 만들어가는 것은 뜻깊은 경험이었다.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>디자이너란 무엇인가, 노먼 포터 저, 최성민 옮김, Specter Press, 2008(번역판), 2002(원판), p77, 5 방법의 문제 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

  </div>
</div>

        <span id="typed"></span>
      </div>
    </div>

    
    
    
    
    
    
    
    
    
    
    
    
    
  </body>
</html>

